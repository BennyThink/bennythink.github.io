<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>土豆不好吃</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="土豆不好吃">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="土豆不好吃">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Benny小土豆">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="土豆不好吃" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">土豆不好吃</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-py-azure-oai-proxy/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/16/py-azure-oai-proxy/index/" class="article-date">
  <time class="dt-published" datetime="2025-03-16T00:00:00.000Z" itemprop="datePublished">2025-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/azure/">azure</a>►<a class="article-category-link" href="/categories/azure/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/16/py-azure-oai-proxy/index/">使用50行Python代码实现一个Azure OpenAI Proxy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[v_error]不要使用 blacksheep，否则你的人生会变得不幸[&#x2F;v_error]</p>
<p>Azure OpenAI和OpenAI提供的服务基本一致的，除了了Azure 更新会慢一点之外，最大的区别是请求路径不同。</p>
<p>对于Azure而言，需要去Azure AI Foundry 里创建部署</p>
<p><img src="/images/202503161933463.png" alt="图形用户界面, 应用程序, Teams AI 生成的内容可能不正确。"></p>
<p>部署名称就是请求时的URL参数的一部分，举例如下</p>
<p><a target="_blank" rel="noopener" href="https://xxx.openai.azure.com/openai/deployments/%7Byour/_deployment/_name%7D/chat/completions?api-version=2024-12-01-preview">https://xxx.openai.azure.com/openai/deployments/{your\_deployment\_name}/chat/completions?api-version=2024-12-01-preview</a></p>
<p><code>api-version</code> 需要根据个人情况选择，新版本的包含更多的功能。</p>
<p>那么问题就简单了，如果要做代理转发，需要做的事情就是创建一个模型名称（如gpt-4-mini）和部署名称的映射表，写一个简单的程序读取body，然后动态拼接为正确的URL，然后请求返回即可。</p>
<p>如果你会写lua，那么直接搭配下openresty就可以了。然而……</p>
<h2 id="选择Web框架"><a href="#选择Web框架" class="headerlink" title="选择Web框架"></a>选择Web框架</h2><p>为了图简单，语言就选Python吧。在网上找到了一个 <a target="_blank" rel="noopener" href="https://klen.github.io/py-frameworks-bench/">Python Web framework的性能对比图</a>，还有一个[比较新的对比图](<a target="_blank" rel="noopener" href="https://www.techempower.com/benchmarks/">https://www.techempower.com/benchmarks/</a>“ \l “hw&#x3D;ph&amp;test&#x3D;composite&amp;section&#x3D;data-r23&amp;l&#x3D;zijzen-cn3)</p>
<p><img src="/images/2025031619334840.png" alt="图片包含 图标 AI 生成的内容可能不正确。"></p>
<p>[v_blue]可惜tornado已经廉颇老矣了，在没有asyncio的那个时代，tornado是王者🥲[&#x2F;v_blue]</p>
<p>信我的，不要选择blacksheep（后面会讲）。这次我们就选择第二名的sanic，文档很好，语法很像flask，原生支持asyncio，星标也很多</p>
<h2 id="非流实现"><a href="#非流实现" class="headerlink" title="非流实现"></a>非流实现</h2><p>非流式响应直接用httpx发请求，然后返回就行了，非常简单，记得跟着把状态码也设置了</p>
<p>代码如下，非常简单，应该不用解释就能看懂</p>
<p>import os</p>
<p>import httpx<br>from sanic import Sanic<br>from sanic import json as json_response<br>from sanic.request import Request</p>
<p>client &#x3D; httpx.AsyncClient(<br>    http2&#x3D;True,<br>    timeout&#x3D;httpx.Timeout(<br>        connect&#x3D;15.0,<br>        read&#x3D;300.0,<br>        write&#x3D;300.0,<br>        pool&#x3D;10.0,<br>    ),<br>)</p>
<p>app &#x3D; Sanic(__name__)</p>
<p>url &#x3D; os.getenv(“URL”)<br>api_key &#x3D; os.getenv(“API_KEY”)</p>
<p>@app.route(“&#x2F;v1&#x2F;chat&#x2F;completions”, methods&#x3D;[“POST”])<br>async def chat_completions(request: Request):<br>    body &#x3D; request.json<br>    if body.get(“stream”):<br>        pass<br>    else:<br>        return await non_stream(body)</p>
<p>async def non_stream(body):<br>    response &#x3D; await client.post(url, json&#x3D;body, headers&#x3D;{“api-key”: api_key})<br>    return json_response(response.json(), status&#x3D;response.status_code)</p>
<p>if __name__ &#x3D;&#x3D; “__main__“:<br>    app.run(host&#x3D;”127.0.0.1”, port&#x3D;8000, debug&#x3D;True, dev&#x3D;True, auto_reload&#x3D;True)</p>
<h2 id="流式实现"><a href="#流式实现" class="headerlink" title="流式实现"></a>流式实现</h2><p>Sanic的流式也很简单，我们直接使用 httpx的<code>stream</code>就可以。</p>
<p>需要注意的是，如果请求参数错误，那么Azure会给返回400类错误，此时不能返回SSE，而且普通的json。这里可以通过<code>response.aread()</code> 来读取响应体。</p>
<p>也就是说代码大概长这样</p>
<p>async with client.stream(“POST”, url, json&#x3D;body, headers&#x3D;{“api-key”: api_key}) as response:<br>    if response.status_code !&#x3D; 200:<br>        error &#x3D; await response.aread()<br>        # 由于 aread() 直接返回了bytes，所以就用raw方法返回，设置content-type为application json，没必要在反序列化一次用json返回<br>        return raw(error, content_type&#x3D;”application&#x2F;json”, status&#x3D;response.status_code)</p>
<p>如果请求正常开始返回，那么就先设置设置<code>content-type</code></p>
<p>server &#x3D; await request.respond(content_type&#x3D;”text&#x2F;event-stream”)</p>
<p>然后去迭代</p>
<p>async for chunk in response.aiter_text():<br>    await server.send(chunk)</p>
<p><img src="/images/2025031619334875.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 AI 生成的内容可能不正确。"></p>
<p>恭喜你，用50行代码实现了代理服务！至于 text-embedding 这种根本不支持流式的模型，甚至可以写一个通用的函数，反正就是原样发送、原样返回</p>
<h2 id="进一步……"><a href="#进一步……" class="headerlink" title="进一步……"></a>进一步……</h2><p>当然， 你可以根据自己的需求进一步扩展。比如说……</p>
<ul>
<li>创建一个yaml配置文件，配置Azure OpenAI区域</li>
<li>配置好deployment和OpenAI model名字的映射表</li>
<li>加上权重</li>
<li>根据一定的算法，如轮询，加权轮询，最少使用等选择最佳区域</li>
<li>过滤响应内容中的字段（比如<code>content_filter_results</code> 之类的）</li>
<li>内容审查</li>
</ul>
<p>用Python操作json可比用Go方便多了！不用两眼一发黑的写type真的是太幸福了！</p>
<p>具体操作空间，那留给自己想象啦！</p>
<h2 id="为什么不要使用-blacksheep"><a href="#为什么不要使用-blacksheep" class="headerlink" title="为什么不要使用 blacksheep"></a>为什么不要使用 blacksheep</h2><p>最开始我选择了blacksheep，因为这个最快嘛，文档看起来也不错。</p>
<p>后来发现踩了很多坑，直接整个一天时间没了🫠……</p>
<h3 id="SSE的序列化"><a href="#SSE的序列化" class="headerlink" title="SSE的序列化"></a>SSE的序列化</h3><p>Blacksheep用SSE是这样子滴：</p>
<p>import asyncio<br>from collections.abc import AsyncIterable</p>
<p>from blacksheep import Application, get<br>from blacksheep.server.sse import ServerSentEvent, ServerSentEventsResponse</p>
<p>app &#x3D; Application()</p>
<h1 id="An-AsyncGenerator-yielding-ServerSentEvent…"><a href="#An-AsyncGenerator-yielding-ServerSentEvent…" class="headerlink" title="An AsyncGenerator yielding ServerSentEvent…"></a>An AsyncGenerator yielding ServerSentEvent…</h1><p>async def events_provider() -&gt; AsyncIterable[ServerSentEvent]:<br>    for i in range(3):<br>        yield ServerSentEvent({“message”: f”Hello World {i}”})<br>        await asyncio.sleep(1)</p>
<h1 id="A-request-handler-returning-a-streaming-response-bound-to-the-generator…"><a href="#A-request-handler-returning-a-streaming-response-bound-to-the-generator…" class="headerlink" title="A request handler returning a streaming response bound to the generator…"></a>A request handler returning a streaming response bound to the generator…</h1><p>@get(“&#x2F;events”)<br>def events_handler():<br>    return ServerSentEventsResponse(events_provider)</p>
<p><code>ServerSentEvent</code> 会自动json序列化你的传入的参数，正常OpenAI最后一个响应是<code>[DONE]</code></p>
<p><img src="/images/2025031619334993.png" alt="图形用户界面, 应用程序 AI 生成的内容可能不正确。"></p>
<p>然而用它你发现……你永远无法正确返回 <code>[DONE]</code>，比如</p>
<p>yield ServerSentEvent(“[DONE]“)<br>yield ServerSentEvent([“DONE”])</p>
<p>你会发现这引号是怎么回事🤡</p>
<p><img src="/images/202503161933491.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 AI 生成的内容可能不正确。"></p>
<p>解决方案是<a target="_blank" rel="noopener" href="https://github.com/Neoteroi/BlackSheep/issues/484">自定义他的json dumps</a>，硬编码一下，如果是<code>[DONE]</code>的时候直接返回</p>
<p>from blacksheep.settings.json import default_json_dumps, json_settings</p>
<p>def custom_dumps(value):<br>    if value &#x3D;&#x3D; “[DONE]“:<br>        return value<br>    else:<br>        return default_json_dumps(value)</p>
<p>json_settings.use(dumps&#x3D;custom_dumps)</p>
<h3 id="异步生成器锁死"><a href="#异步生成器锁死" class="headerlink" title="异步生成器锁死"></a>异步生成器锁死</h3><p>Blacksheep是使用的异步生成器，看<code>yield</code>和<code>async</code>就知道。但是在流式请求的时候，如果azure返回了错误json，我们也要返回错误json给客户端，而不是返回SSE。</p>
<p>然而……一旦你用了yield+async，这个函数就是异步生成器函数了，你可以使用<code>return</code>结束生成器，但是却不能使用 <code>return 123</code>这样的表达式。</p>
<p>所以试图在 <code>as response</code>后判断状态码，然后试图返回一个json的操作，比如</p>
<p>return json({“message”: “Hello, World!”})</p>
<p>都是不行滴！</p>
<p><img src="/images/2025031619335077.png" alt="图形用户界面, 文本 AI 生成的内容可能不正确。"></p>
<h3 id="SSE锁死"><a href="#SSE锁死" class="headerlink" title="SSE锁死"></a>SSE锁死</h3><p>实际上，当你路由中调用<code>return ServerSentEventsResponse(events_provider)</code>后，整个请求只可能以SSE的格式返回了🫠</p>
<p>聪明的你可能会想着既然不能<code>return</code>，那我<code>yield</code>一下</p>
<p>if response.status_code !&#x3D; HTTPStatus.OK:<br>    content &#x3D; await response.aread()<br>    yield content<br>    return</p>
<p>IDE没报错，但是运行时……</p>
<p>TypeError: Argument ‘event’ has incorrect type (expected blacksheep.contents.ServerSentEvent, got bytes)</p>
<p>别想着改type annotation了，不管用的🤣</p>
<h3 id="提升-httpx-Client-也没用"><a href="#提升-httpx-Client-也没用" class="headerlink" title="提升 httpx.Client 也没用"></a>提升 httpx.Client 也没用</h3><p>我也想到了这个办法，先在路由后调用 <code>client.stream()</code> 然后看status code是不是200，如果是，那么走 <code>return ServerSentEventsResponse</code> 否则就是 return json</p>
<p>恭喜你！发现了新的坑！你会发现……</p>
<p>raise StreamClosed() httpx.StreamClosed: Attempted to read or stream content, but the stream has been closed.</p>
<p>那尝试手动进入，不用<code>async with</code>了</p>
<p>stream_ctx &#x3D; client.stream(   )<br>stream_response &#x3D; await stream_ctx.__aenter__()<br>….<br>return ServerSentEventsResponse(partial(stream_provider, stream_ctx, stream_response))</p>
<p>很好</p>
<p>line 155, in stream_provider<br>async for c in stream_response.aiter_text():<br>httpx.ReadTimeout</p>
<p>那就闭包，用前朝的剑指挥今朝的兵！这样的话，其实上面错误差不多😂</p>
<h3 id="唯一可能的解决方案……"><a href="#唯一可能的解决方案……" class="headerlink" title="唯一可能的解决方案……"></a>唯一可能的解决方案……</h3><p>给Azure返回的<code>chunks</code>都缓存起来，等都返回完了，把全部<code>chunks</code>交<code>stream_provider</code>，流式直接变非流👍真有你的</p>
<p>抛出一个自定义异常的办法也许管用，但是我一直没接住……</p>
<p>所以，不要使用 blacksheep，否则你的人生会变得不幸</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>完整代码可见 <a target="_blank" rel="noopener" href="https://gist.github.com/BennyThink/94ac6e088feb1cec829cf7c280c56783">https://gist.github.com/BennyThink/94ac6e088feb1cec829cf7c280c56783</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/16/py-azure-oai-proxy/index/" data-id="cm8c7uxyn00003zjf7syn157r" data-title="使用50行Python代码实现一个Azure OpenAI Proxy" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-candlestick-llm/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/12/candlestick-llm/index/" class="article-date">
  <time class="dt-published" datetime="2024-12-12T00:00:00.000Z" itemprop="datePublished">2024-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/what/">what</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/12/candlestick-llm/index/">使用Python 通过K线计算技术指标，并用 LLM 预测趋势</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>经常混币圈、股票和外汇的朋友们都知道有一个东西叫 K线，大概长这样 <img src="/images/2024121202224065.png" alt="pasted-movie.png"></p>
<p>同时你也可以选择添加更多的图表，如布林线、MACD、RSI等，用这些技术指标来辅助决策。</p>
<p><img src="/images/2024121202224114.png" alt="pasted-movie.png"></p>
<p>这些技术参数很有用，如果能把一段时间的结果交给LLM去分析，应该比凭着感觉瞎买更靠谱吧！</p>
<p>那这些技术参数是怎么来的呢……？</p>
<p>去花钱买！这个世界上还有什么是钞能力无法解决的事情吗？</p>
<p><img src="/images/9974-kherpxx2653922.gif" alt="第一白富美丢250亿遗产，跑去当网红捞钱？"></p>
<p><a target="_blank" rel="noopener" href="https://taapi.io/">https://taapi.io/</a> 已经有人做好了！有股票 也有加密货币的数据。就是……免费版频率限制有些严重，想要获取多点数据就等几个小时吧。一下子升级个 Pro 要花14.99欧元，在PoC阶段好像也不太值得……</p>
<p>实际上，这些技术参数，全部都是使用K线数据，由客户端计算出来的。K线数据很容易获取，很多交易所都提供API，但是计算这些参数需要比较强的数学知识😅</p>
<p>还好已经有人写好了相关的库，虽然是 C&#x2F;C++写的，但是不怕啦早就有人写好了 Python的wrapper</p>
<h2 id="TA-Lib-Technical-Analysis-Library"><a href="#TA-Lib-Technical-Analysis-Library" class="headerlink" title="TA-Lib - Technical Analysis Library"></a>TA-Lib - Technical Analysis Library</h2><p>我们需要这个东西来计算数据，这个库支持200多个技术指标，包括RSI，MACD</p>
<p>安装方式可以参考官方文档</p>
<h2 id="获取K线数据"><a href="#获取K线数据" class="headerlink" title="获取K线数据"></a>获取K线数据</h2><p>以币安的合约数据为例，非常简单</p>
<p>pip install binance-futures-connector<br>from binance.um_futures import UMFutures<br>um_client &#x3D; UMFutures()<br>candles&#x3D;um_client.klines(symbol&#x3D;‘BTCUSDT’, interval&#x3D;‘1m’)</p>
<p>这样我们就获取到了 1分钟时间间隔的数据</p>
<p>转换成 pandas的<code>DataFrame</code> 方便后续处理</p>
<p>pd.DataFrame(candles)</p>
<h2 id="计算布林线"><a href="#计算布林线" class="headerlink" title="计算布林线"></a>计算布林线</h2><p>布林线使用收盘价格进行计算，而且需要多组数据才可以计算出来</p>
<p>upperband, middleband, lowerband &#x3D; talib.BBANDS(self.df[“close”], timeperiod&#x3D;20, nbdevup&#x3D;2, nbdevdn&#x3D;2, matype&#x3D;0)</p>
<h2 id="计算-RSI"><a href="#计算-RSI" class="headerlink" title="计算 RSI"></a>计算 RSI</h2><p>同样也是收盘价</p>
<p>rsi6 &#x3D; talib.RSI(self.df[“close”], timeperiod&#x3D;6)<br>rsi12 &#x3D; talib.RSI(self.df[“close”], timeperiod&#x3D;12)<br>rsi24 &#x3D; talib.RSI(self.df[“close”], timeperiod&#x3D;24)</p>
<h2 id="MACD"><a href="#MACD" class="headerlink" title="MACD"></a>MACD</h2><p>收盘价</p>
<p>dif, dea, macd &#x3D; talib.MACD(self.df[“close”], fastperiod&#x3D;12, slowperiod&#x3D;26, signalperiod&#x3D;9)</p>
<h2 id="MA"><a href="#MA" class="headerlink" title="MA"></a>MA</h2><p>包括SMA和EMA</p>
<p>sma7 &#x3D; talib.SMA(self.df[“close”], timeperiod&#x3D;7)<br>sma25 &#x3D; talib.SMA(self.df[“close”], timeperiod&#x3D;25)<br>sma99 &#x3D; talib.SMA(self.df[“close”], timeperiod&#x3D;99)</p>
<p>ema7 &#x3D; talib.EMA(self.df[“close”], timeperiod&#x3D;7)<br>ema25 &#x3D; talib.EMA(self.df[“close”], timeperiod&#x3D;25)<br>ema99 &#x3D; talib.EMA(self.df[“close”], timeperiod&#x3D;99)</p>
<h2 id="转换数据为json"><a href="#转换数据为json" class="headerlink" title="转换数据为json"></a>转换数据为json</h2><p>LLM更适合处理json数据，pandas就很方便啦</p>
<p>self.df.to_json(orient&#x3D;”records”, date_format&#x3D;”epoch”, date_unit&#x3D;”s”)</p>
<h2 id="调用-LLM-接口"><a href="#调用-LLM-接口" class="headerlink" title="调用 LLM 接口"></a>调用 LLM 接口</h2><p>有了数据之后就可以把他们导出成 json，然后调用LLM进行处理。</p>
<p>这里需要找一个可用的LLM，比如 Mistral AI、OpenAI 、Gemini或者 Claude。由于国内注册比较麻烦，而且风控很严格，建议大家使用「头顶冒火」的API接口</p>
<ul>
<li>OpenAI专场：<a target="_blank" rel="noopener" href="https://burn.hair/">https://burn.hair/</a></li>
<li>Claude、MistralAI和OpenAI：<a target="_blank" rel="noopener" href="https://api.burn.hair/">https://api.burn.hair/</a></li>
</ul>
<p>使用什么模型因人而异，一次数据量比较大，gpt-4o可能是比较好的选择，Claude Opus和o1-preview比较贵，但是也可以考虑，头顶冒火网站也都有的</p>
<p>然后要做的事情就是写提示词，让AI分析结果了！🧐</p>
<p>很麻烦是不是……不要怕，我已经写好并且开源了。使用方式详见下一页！⬇️⬇️⬇️ 部分RSS阅读器可能无法显示下一页的内容，请点击链接打开网站阅读</p>
<p> </p>
<p>[v_error]本项目仅供学习交流使用。交易有风险，入市需谨慎。若因本项目产生任何损失，概不负责。[&#x2F;v_error]</p>
<p>下面即将以Windows为例手把手教学，至于 macOS和Linux，基本步骤也基本一致</p>
<h2 id="安装编辑器"><a href="#安装编辑器" class="headerlink" title="安装编辑器"></a>安装编辑器</h2><p>需要一个比较好的编辑器来编辑配置文件，可以选择Sublime、Notepad++，也可以选择 VS Code</p>
<p>以 VS Code为例，到这里下载 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/%EF%BC%8C">https://code.visualstudio.com/，</a> 下载回来双击下一步就可以</p>
<h2 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h2><p>到这里<a target="_blank" rel="noopener" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> 下载并安装 Python</p>
<p><img src="/images/2024121202224340.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h2 id="准备代码"><a href="#准备代码" class="headerlink" title="准备代码"></a>准备代码</h2><p>打开网址 <a target="_blank" rel="noopener" href="https://github.com/BennyThink/AICryptoBot">https://github.com/BennyThink/AICryptoBot</a></p>
<p>Code – Download Zip 或者选择 git clone等方式</p>
<p><img src="/images/202412120222449.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>对于ZIP文件，请自行解压缩</p>
<h2 id="打开项目"><a href="#打开项目" class="headerlink" title="打开项目"></a>打开项目</h2><p>双击打开VS Code，然后把目录拖进去即可打开，能看到这样的目录结构就说明正确了</p>
<p><img src="/images/2024121202224549.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>VSCode 菜单栏 Terminal – New Terminal</p>
<p>如果网络速度不理想，需要配置镜像</p>
<p>pip config set global.index-url <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/pypi/simple">https://mirrors.ustc.edu.cn/pypi/simple</a><br>pip install -r requirements.txt</p>
<p>pip install <a target="_blank" rel="noopener" href="https://github.com/cgohlke/talib-build/releases/download/v0.5.1/ta/_lib-0.5.1-cp313-cp313-win/_amd64.whl">https://github.com/cgohlke/talib-build/releases/download/v0.5.1/ta\_lib-0.5.1-cp313-cp313-win\_amd64.whl</a></p>
<p>如果你安装不是 Python 3.13 需要把上面的<code>cp313</code>换成<code>cp312</code>（3.12）<code>cp311</code>（3.11）以此类推</p>
<h2 id="准备-LLM接口"><a href="#准备-LLM接口" class="headerlink" title="准备 LLM接口"></a>准备 LLM接口</h2><p>这里以 OpenAI + 头顶冒火为例，需要先去 <a target="_blank" rel="noopener" href="https://burn.hair/">https://burn.hair/</a> 或者 <a target="_blank" rel="noopener" href="https://api.burn.hair/">https://api.burn.hair/</a> 注册一个账号，然后确保有足够余额（0.5-1美元就足够了）。</p>
<p>令牌-添加令牌</p>
<p><img src="/images/2024121202224554.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<p>然后复制令牌</p>
<h2 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h2><p>创建一个 <code>.env</code>文件放到 <code>src</code> 这个子目录下,内容如下</p>
<p>OPENAI_BASE_URL&#x3D;<a target="_blank" rel="noopener" href="https://burn.hair/v1">https://burn.hair/v1</a><br>OPENAI_API_KEY&#x3D;sk-61234这里就是你复制的令牌<br>OPENAI_MODEL&#x3D;gpt-4o-2024-08-06</p>
<p>BINANCE_INTERVAL&#x3D;1m&#x3D;30,5m&#x3D;40,15m&#x3D;30,1h&#x3D;25,2h&#x3D;15,4h&#x3D;10,8h&#x3D;8,12h&#x3D;6,1d&#x3D;5</p>
<p>BINANCE_INTERVAL 详解：</p>
<p>这里需要根据你的需求，来配置采集的时间间隔和数据量，<code>1m=30</code>表示1分间隔的数据采集最近30个；同理，<code>1d=5</code> 意味着1天的间隔，采集5个，换句话说也就是5天的日线数据。数据量越多，API消耗也就越多，按照默认配置大概1个交易对要用0.1-0.2美元。</p>
<p>可以根据个人情况调整，如果拿不准可以用默认值，或者让AI给出个主意</p>
<h2 id="运行测算"><a href="#运行测算" class="headerlink" title="运行测算"></a>运行测算</h2><p>同样在 Terminal里</p>
<p>cd src</p>
<h1 id="多个交易对可以用逗号分隔，如"><a href="#多个交易对可以用逗号分隔，如" class="headerlink" title="多个交易对可以用逗号分隔，如"></a>多个交易对可以用逗号分隔，如</h1><p>python main.py –symbol&#x3D;btcusdt,ethusdt</p>
<h1 id="只想查询一个可以这样"><a href="#只想查询一个可以这样" class="headerlink" title="只想查询一个可以这样"></a>只想查询一个可以这样</h1><p>python main.py –symbol&#x3D;btcusdt</p>
<p><img src="/images/2024121202224697.png" alt="图形用户界面 低可信度描述已自动生成"></p>
<p>然后浏览器就会自动打开一个网页显示结果，也可以在output目录下找到html文件打开自行查看</p>
<p><img src="/images/2024121202224868.png" alt="图形用户界面, 文本, 应用程序描述已自动生成"></p>
<p>看起来是不是挺靠谱的样子，至少比自己凭着感觉瞎买要好多了。再次警告，<strong>交易有风险，入市需谨慎。若因本项目产生任何损失，概不负责。</strong></p>
<p> </p>
<p>要是赚到钱了，可以考虑<a target="_blank" rel="noopener" href="https://github.com/BennyThink/AICryptoBot?tab=readme-ov-file#%E8%B5%9E%E8%B5%8F">给我打个赏</a>😂</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>代码开源地址：<a target="_blank" rel="noopener" href="https://github.com/BennyThink/AICryptoBot">https://github.com/BennyThink/AICryptoBot</a></li>
<li>头顶冒火 OpenAI 接口站：限时折扣优惠进行中，<a target="_blank" rel="noopener" href="https://burn.hair/">https://burn.hair/</a></li>
<li>头顶冒火小分队，支持 Claude、MistralAI、Grok和 OpenAI，纯官方转发：<a target="_blank" rel="noopener" href="https://api.burn.hair/">https://api.burn.hair/</a></li>
<li>TA-Lib：<a target="_blank" rel="noopener" href="https://ta-lib.org/">https://ta-lib.org/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/12/candlestick-llm/index/" data-id="cm4lwgy6w0000tdjfcn828igf" data-title="使用Python 通过K线计算技术指标，并用 LLM 预测趋势" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-warp-http-proxy/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/03/warp-http-proxy/index/" class="article-date">
  <time class="dt-published" datetime="2024-11-03T00:00:00.000Z" itemprop="datePublished">2024-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cloudflare/">cloudflare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/03/warp-http-proxy/index/">把 Cloudflare WARP 转换为 http 代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Cloduflare WARP真的非常好用，并且支持代理模式。启用这个模式之后，它会在本机监听一个socks端口，应用程序可以配置到这个端口来使用代理。</p>
<p>对于服务器来说，一般使用 <code>warp-cli</code></p>
<p>warp-cli proxy port 60606<br>warp-cli mode proxy</p>
<p>之后你就可以 <code>curl</code> 啦</p>
<p>https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:60606 http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:60606 curl ipv4.win<br>IP: 104.28.157.116 CLOUDFLARE.COM CLOUDFLARE.COM</p>
<p>然而，Go的程序不支持 socks 代理，要手动加transport我可没那个功夫去加。</p>
<p>好消息是，Go默认是尊重环境变量<code>http_proxy</code>的。那么就要想办法给socks代理转换为http代理</p>
<p>这事很简单嘛！用<code>pproxy</code>就好了，别的不会，这个肯定很会！</p>
<p>pproxy -v -l <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -r socks5:&#x2F;&#x2F;127.0.0.1:60606</p>
<p>https_proxy&#x3D;<a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> http_proxy&#x3D;<a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> curl ipv4.win<br>curl: (52) Empty reply from server</p>
<h1 id="pproxy-logs"><a href="#pproxy-logs" class="headerlink" title="pproxy logs"></a>pproxy logs</h1><p>Serving on ipv? 127.0.0.1:8118 by http<br>http 127.0.0.1:45012 -&gt; socks5 127.0.0.1:60606 -&gt; ipv4.win:80<br>Unknown remote protocol from 127.0.0.1</p>
<p><img src="/images/2024110320441822.png" alt="女孩在微笑"></p>
<p>怎么报错了呢🤨</p>
<p>可能是 <code>pproxy</code>的问题，那么用<code>gost</code>！</p>
<p>gost -L <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -F socks5:&#x2F;&#x2F;127.0.0.1:60606<br>2024&#x2F;11&#x2F;03 12:32:43 route.go:700: <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> on 127.0.0.1:8118<br>2024&#x2F;11&#x2F;03 12:32:46 http.go:162: [http] 127.0.0.1:33284 -&gt; <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -&gt; ipv4.win:80<br>2024&#x2F;11&#x2F;03 12:32:46 http.go:257: [route] 127.0.0.1:33284 -&gt; <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -&gt; 1@socks5:&#x2F;&#x2F;127.0.0.1:60606 -&gt; ipv4.win:80<br>2024&#x2F;11&#x2F;03 12:32:46 http.go:280: [http] 127.0.0.1:33284 -&gt; 127.0.0.1:8118 : unexpected EOF</p>
<p><img src="/images/2024110320441992.png" alt="人生成"></p>
<p>那……Privoxy</p>
<p>forward-socks5 &#x2F; 127.0.0.1:60606 .</p>
<p>也不行！</p>
<p><img src="/images/2024110320441976.png" alt="长发的女孩"></p>
<p>甚至直接在 Firefox里设置socks5代理，也不行🤨</p>
<p><img src="/images/2024110320442061.jpeg" alt="图形用描述已自动生成"></p>
<p>任何网站都打不开</p>
<p><img src="/images/2024110320442094.jpeg" alt="图形用邮件生成"></p>
<p>偶然取消 DNS请求的勾选，就成功了……突然恍然大悟，WARP可能不支持远程解析DNS<img src="/images/20241103204421100.png" alt="戴着帽子的人自动生成"></p>
<p> </p>
<p>那么要么用回 socks4</p>
<p>pproxy -v -l <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -r socks4:&#x2F;&#x2F;127.0.0.1:60606<br>gost -L <a target="_blank" rel="noopener" href="http://127.0.0.1:8118/">http://127.0.0.1:8118</a> -F socks4:&#x2F;&#x2F;127.0.0.1:60606</p>
<p>要么给加上DNS的支持</p>
<p>gost -L “<a target="_blank" rel="noopener" href="http://127.0.0.1:8118/?dns=1.1.1.1">http://127.0.0.1:8118?dns=1.1.1.1</a>“ -F socks5:&#x2F;&#x2F;127.0.0.1:60606</p>
<p>人生中宝贵的几个小时就这么没了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/03/warp-http-proxy/index/" data-id="cm326aqtt0000acjf7n2m6jij" data-title="把 Cloudflare WARP 转换为 http 代理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-aca-php/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/aca-php/index/" class="article-date">
  <time class="dt-published" datetime="2024-10-12T00:00:00.000Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/azure/">azure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/aca-php/index/">用 Azure Container Apps 运行PHP网站</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>既然是容器，那么也可以跑数据库的吧？那只要再加上一个PHP，就可以跑 WordPress、Typecho之类的应用了！</p>
<p>在 Azure上，用 Container Apps也是可以做到serverless PHP应用的，具体来说就是：</p>
<p>一个pod里开两个容器（不太推荐这种方式），一个是php-apache，一个是MySQL，通过挂载 Azure Files作为volumes来做数据存储。</p>
<p>为什么想这么玩，是因为：</p>
<ol>
<li>优化大陆访问，Azure的亚洲机房对大陆访客很友好，因此不能用 Cloudflare</li>
<li>不想自己管理SSL证书，因此不能用vm</li>
<li>managed database太贵了用不起</li>
<li>FrontDoor也太贵了，每个月要$35的保护费🥹</li>
</ol>
<p>使用这种方案的好处是，在访问量不是很大的情况下，成本应该可以忽略不计，甚至可以在无访问时缩放到0副本，真正“无服务器” 😂</p>
<h2 id="创建资源组"><a href="#创建资源组" class="headerlink" title="创建资源组"></a>创建资源组</h2><p>创建资源组，创建一个vnet，因为存储不想公开给所有人，也方便以后和其他虚拟机内网互通。</p>
<h2 id="创建容器应用"><a href="#创建容器应用" class="headerlink" title="创建容器应用"></a>创建容器应用</h2><p>创建的时候，Container Apps Environment 选择已有的虚拟网络</p>
<p><img src="/images/2024100701193586.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<p>配置镜像，这个镜像是我自己构建的，基于 php:8.3-apache，支持MySQL、PostgreSQL、SQLite，添加了 mod_rewrite，足够给WordPress和Typecho用</p>
<p><img src="/images/2024100701193677.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h2 id="创建存储"><a href="#创建存储" class="headerlink" title="创建存储"></a>创建存储</h2><p>Primary Service选择 Azure Files</p>
<p><img src="/images/2024100701193849.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h3 id="创建-File-Shares"><a href="#创建-File-Shares" class="headerlink" title="创建 File Shares"></a>创建 File Shares</h3><p><img src="/images/2024100701194097.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<p>我创建了两个，一个是数据库的，一个是网站文件的</p>
<p><img src="/images/2024100701194256.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h2 id="连接-volume到容器"><a href="#连接-volume到容器" class="headerlink" title="连接 volume到容器"></a>连接 volume到容器</h2><p>在创建完存储后，去复制一下access key</p>
<p><img src="/images/2024100701194419.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>在容器环境中添加 SMB</p>
<p><img src="/images/2024100701194669.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>依次输入信息，这里没有补全，不要输入错了哦</p>
<p><img src="/images/2024100701194777.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>在容器环境中创建完之后，就可以到容器应用中添加啦</p>
<p><img src="/images/202410070119481.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<p>这里需要注意，数据库的卷可能需要如下额外挂载参数</p>
<p>uid&#x3D;999,gid&#x3D;999,nobrl,mfsymlinks,cache&#x3D;none</p>
<h2 id="容器应用volume"><a href="#容器应用volume" class="headerlink" title="容器应用volume"></a>容器应用volume</h2><p>编辑容器，添加volume就可以了</p>
<p><img src="/images/2024100701195029.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>然后添加一个数据库的sidecar</p>
<p><img src="/images/2024100701195170.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>如果需要配置环境变量，也可以一起配置了</p>
<p><img src="/images/2024100701195239.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>最终结果是这样的两个容器，在一个pod里，我这种穷人自然只能选择最低配置啦</p>
<p><img src="/images/2024100701195346.png" alt="图形用户界面, 表格 描述已自动生成"></p>
<h2 id="存储安全"><a href="#存储安全" class="headerlink" title="存储安全"></a>存储安全</h2><p>默认存储是可以公网访问的（需要用户名密码），为了更安全，我们可以配置为只有某几个虚拟网络可以访问</p>
<p><img src="/images/2024100701195455.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p>
<h2 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h2><p>可能需要进入 console，执行一下创建数据库之类的操作，这点就自行发挥了。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>在不使用的时候，容器可以缩为0（可以配置为最低1副本）</p>
<p><img src="/images/202410070119559.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>在有请求的时候，真的能访问耶，而且还可以自动扩容！</p>
<p><img src="/images/2024100701195835.png" alt="图形用户界面, 网站 描述已自动生成"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正常的应用不应该这样配置的，两个容器在同一个pod内耦合也是不理想的。</p>
<p>如果想要利用 Azure的优良线路，正常来说应该选择如下方法之一</p>
<ol>
<li>Azure VM，自己配置SSL证书，域名解析到这个IP，最经典的操作</li>
<li>Azure FrontDoor + 任意VM，SSL证书可以由FrontDoor管理</li>
<li>Azure应用网关 + 任意VM，解析域名到网关的IP，配置SSL证书，然后上传证书给应用网关</li>
<li>Azure Load Balancer + 任意VM，证书需要在VM上配置好，因为LB是4层的</li>
<li>Container Apps运行PHP，用托管数据库，Container Apps支持托管SSL</li>
<li>Container Apps运行PHP，通过VM运行数据库，两者网络之间创建对等连接</li>
<li>Static Web Apps，只能给静态站点用</li>
<li>Web App + Database，完全托管，价格很感人</li>
<li>Azure Kubernetes Service ，这个我可能不太懂，但是应该可行……</li>
</ol>
<hr>
<p>最后……</p>
<blockquote>
<p>PHP用什么跑不好要用这个，真是只有真正的赛博精神病才能够想出来这种操作🤡</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/12/aca-php/index/" data-id="cm26qm18p0000jwjfgxhkeyfl" data-title="用 Azure Container Apps 运行PHP网站" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-aca-vm-scale/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/06/aca-vm-scale/index/" class="article-date">
  <time class="dt-published" datetime="2024-10-06T00:00:00.000Z" itemprop="datePublished">2024-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/azure/">azure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/06/aca-vm-scale/index/">Azure Container Apps 连接到虚拟机并配置CPU自动缩放</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我的所有的代码最终都做成了 Docker image，因此可以非常方便的拿出来部署，自然也可以部署在各种 managed container或者managed k8s的环境。</p>
<p>更重要的是，Azure Container Apps 提供一定的免费额度，一般普通用户都够用的了！</p>
<p>这次的情况有点特殊：</p>
<ol>
<li>如何部署到 Azure Container Apps上，并且让这个容器可以与 Azure 内的某虚拟机内网互通？</li>
<li>在CPU使用率比较高的情况下，如何自动扩容？如果做不到这点那也没必要用托管k8s了呀</li>
</ol>
<h2 id="虚拟网络"><a href="#虚拟网络" class="headerlink" title="虚拟网络"></a>虚拟网络</h2><p>通常来说，在 Azure 上的虚拟机，如果是同一个数据中心的，想要内网互通，直接都创建在一个虚拟网络下就可以了，默认情况下就是互通的，而且默认的安全组是允许同一个虚拟网络的通信的。</p>
<p>如果是不同的数据中心，或者不同的订阅，那么就要创建不同的虚拟网络，不同的网段，然后创建 peering</p>
<p><img src="/images/2024100600441925.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<p>创建的过程非常简单，鼠标点点下一步就可以了</p>
<p><img src="/images/2024100600442015.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h2 id="容器应用的虚拟网络"><a href="#容器应用的虚拟网络" class="headerlink" title="容器应用的虚拟网络"></a>容器应用的虚拟网络</h2><p>容器应用需要使用独享的虚拟网络，因此没法重复利用虚拟机已有的虚拟网络。</p>
<p>在创建容器应用时，选择数据中心，这里就建议就近选择啦。然后Container Apps Environment 点击create new</p>
<p><img src="/images/2024100600442151.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>在新的窗口中选择 Networking，配置自己的虚拟网络，如果你的容器不需要被访问，那么甚至可以选择 internal</p>
<p><img src="/images/2024100600442291.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h2 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h2><p>下一步需要配置我们使用什么镜像</p>
<p><img src="/images/20241006004423100.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>需要注意的是 Command Override和Arguments Override这两个。Command Override并不是<code>docker</code>和<code>docker-compose</code>中的<code>command</code>，比如你像 <code>docker-compose.yml</code>里这样写的</p>
<p>services:<br>  generic:<br>    image: ghcr.io&#x2F;webp-pt&#x2F;webplb:latest<br>    command: webplb -mode&#x3D;worker -queue&#x3D;generic</p>
<p>，把这个<code>webplb -mode=worker -queue=generic</code>复制到 Azure Portal上，那就错了……</p>
<ul>
<li>Command Override：指的是<strong>ENTRYPOINT</strong></li>
<li>Arguments Override：指的是 <strong>CMD</strong> 😢</li>
</ul>
<p>那就简单了嘛！直接把 <code>webplb -mode=worker -queue=generic</code> 这一串粘贴到 Arguments Override的文本框，恭喜你又错了🎉。</p>
<p>因为，每一个参数都要用逗号和空格隔开，正确的形式是这样的</p>
<p>webplb, -mode&#x3D;worker, -queue&#x3D;generic</p>
<p>再接下来选择容器的配置，小到 0.25C 0.5G RAM，大到 4C 8G都在这里，如需环境变量也可以一起配置</p>
<p><img src="/images/2024100600442378.png" alt="图形用户界面 描述已自动生成"></p>
<p>再下一步选择端口映射，一个是容器的一个是发布的端口</p>
<p><img src="/images/2024100600442547.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<p>创建的过程比较慢，大概要10-20分钟。如果你的应用有 ingress，那么还会看到一个 Application URL。</p>
<h2 id="测试通信"><a href="#测试通信" class="headerlink" title="测试通信"></a>测试通信</h2><p>容器创建好之后，在 Monitoring – Console 可以连接到容器，或者说是pod内部，之后可以用ping……嗯？😐 <a target="_blank" rel="noopener" href="https://twitter.com/BennyThinks/status/1841504445932482735">其实是通的</a>，nc一下就知道了，我检查了很多地方也检查了安全组的ICMP配置，但是还是没法ping通不过就这样了吧😐</p>
<p><img src="/images/2024100600442656.png" alt="文本 描述已自动生成"></p>
<h2 id="配置缩放"><a href="#配置缩放" class="headerlink" title="配置缩放"></a>配置缩放</h2><h3 id="http-scaler"><a href="#http-scaler" class="headerlink" title="http-scaler"></a>http-scaler</h3><p>通过http请求数量去扩容，实时的，默认就应该有这条规则，可以根据自身的情况进行配置。在满足条件时会自动扩容</p>
<p><img src="/images/2024100600442632.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="CPU使用率缩放"><a href="#CPU使用率缩放" class="headerlink" title="CPU使用率缩放"></a>CPU使用率缩放</h3><p>需要使用 Custom，azure使用的是<a target="_blank" rel="noopener" href="https://keda.sh/docs/2.15/scalers/cpu/">KEDA</a>， 在metadata中填入两个字段</p>
<ul>
<li>type，有使用率Utilization和平均值AverageValue两种</li>
<li>value：值</li>
</ul>
<p>比如下图的写法，就是CPU使用率超过80%就触发；内存也同理，只需要把cpu改成memory就可以</p>
<p><img src="/images/2024100600442868.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="缩放上下限"><a href="#缩放上下限" class="headerlink" title="缩放上下限"></a>缩放上下限</h3><p>在这里可以配置缩放的上下限，上限是1000，下限……可以选择0。</p>
<p><img src="/images/2024100600442893.png" alt="图形用户界面, 应用程序, 电子邮件 描述已自动生成"></p>
<p>对于 Container Apps来说，最低副本数量是可以为0的。这意味着，如果你的网站没有收到任何流量或请求，ACA 将会自动缩减到零副本，从而节省资源。</p>
<p>当然这样有一定的冷启动时间……所以如果希望长时间运行，可以改成1或者任何合适的数值。</p>
<p>需要注意的是，缩放出来的新的容器的配置，都和最开始创建时配置的是一样的哦。</p>
<h3 id="默认缩放行为"><a href="#默认缩放行为" class="headerlink" title="默认缩放行为"></a>默认缩放行为</h3><p>轮询间隔30秒（KEDA），冷却期300秒。这些参数无法改动。</p>
<h2 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h2><p>如果镜像更新了，或者需要更改配置，在 Azure Portal上也可以轻松完成</p>
<p>Containers – Edit and deploy 在下面container image这里就可以重新配置了，包括环境变量在内。</p>
<p>当然了懂得都懂，一个pod可以包含多个container，这里也可以加另外一个container的。</p>
<p><img src="/images/202410060044297.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p><img src="/images/2024100600443051.jpeg" alt="图形用户界面, 文本, 应用程序, 聊天或短信 描述已自动生成"></p>
<p>这我是没想到的！</p>
<p>在急需扩容的时候，我的代码却出了问题，导致程序直接卡死并不退出，无法触发扩容规则🤡</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>在 Azure 容器应用中设置缩放规则 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/azure/container-apps/scale-app?pivots=azure-portal">https://learn.microsoft.com/zh-cn/azure/container-apps/scale-app?pivots=azure-portal</a></p>
<p>Scaling options in Azure Container Apps <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/t5/apps-on-azure-blog/scaling-options-in-azure-container-apps/ba-p/3878282">https://techcommunity.microsoft.com/t5/apps-on-azure-blog/scaling-options-in-azure-container-apps/ba-p/3878282</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/06/aca-vm-scale/index/" data-id="cm1y5yv0e0000lqjf4g50ei5i" data-title="Azure Container Apps 连接到虚拟机并配置CPU自动缩放" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-worker-image-metadata/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/28/worker-image-metadata/index/" class="article-date">
  <time class="dt-published" datetime="2024-09-28T00:00:00.000Z" itemprop="datePublished">2024-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cloudflare/">cloudflare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/28/worker-image-metadata/index/">使用 Cloudflare Worker获取图片元数据</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>WebP Cloud 提供一个接口，可以用于获取图片的元数据，比如长宽、大小、色彩空间以及blurhash。这部分计算，尤其是blurhash其实还是略有压力的，我们就想能不能把这部分功能放到回源请求上。</p>
<p>对于 Azure Function来说，这必然不是问题，因为他几乎就是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/azure/developer/javascript/how-to/develop-serverless-apps?tabs=v4-ts">一个完整的NodeJS环境</a>，可以用sharp的；但是对于Workers，<a target="_blank" rel="noopener" href="https://developers.cloudflare.com/workers/reference/how-workers-works/">由于他是V8</a>，只支持<a target="_blank" rel="noopener" href="https://developers.cloudflare.com/workers/runtime-apis/nodejs/">NodeJS最基本的一些API</a>，最多<a target="_blank" rel="noopener" href="https://developers.cloudflare.com/workers/runtime-apis/webassembly/">带上Wasm</a>，这样用sharp就变成了几乎不可能的事情，因为要调用libvips。</p>
<p>最终经过了我的艰苦探索，发现一个名为 <code>@cf-wasm/photon</code> 的库，可以用来获取图片基础信息。首先需要 import</p>
<p>import { PhotonImage, SamplingFilter, resize } from ‘@cf-wasm&#x2F;photon’;</p>
<p>用起来也还行，首先我们需要通过 <code>fetch</code>获取图片，得到一个<code>response</code>，可以从这里拿到 <code>ArrayBuffer</code></p>
<p>const response &#x3D; await fetch(url)<br>const buffer &#x3D; await response.arrayBuffer();</p>
<p>然后<code>PhotonImage</code> 需要<code>Uint8Array</code>，那先转换一下</p>
<p>const inputBytes &#x3D; new Uint8Array(buffer);</p>
<p>然后加载图片</p>
<p>const inputImage &#x3D; PhotonImage.new_from_byteslice(inputBytes);</p>
<p>宽高可以用 <code>inputImage.get_width()</code>和<code>inputImage.get_height()</code></p>
<p>色彩空间可以用 <code>inputImage.get_image_data().colorSpace</code></p>
<p>文件大小直接 <code>buffer.length</code>就行</p>
<p>计算 blurhash建议先调整图片大小，毕竟 Worker有执行时间限制</p>
<p>const resized &#x3D; resize(inputImage, 32, 32, SamplingFilter.Nearest);</p>
<p>然后计算</p>
<p>const blur &#x3D; encode(resized.get_raw_pixels(), resized.get_width(), resized.get_height(), 4, 4);</p>
<p>至于图片格式，那只能靠magic header了，比如使用如下ChatGPT给我的神奇代码</p>
<p>function getImageFormatFromArrayBuffer(arrayBuffer) {<br>    const uint8Array &#x3D; new Uint8Array(arrayBuffer);</p>
<pre><code>// Check for PNG (first 8 bytes: 89 50 4E 47 0D 0A 1A 0A)
if (
    uint8Array\[0\] === 0x89 &amp;&amp;
    uint8Array\[1\] === 0x50 &amp;&amp;
    uint8Array\[2\] === 0x4e &amp;&amp;
    uint8Array\[3\] === 0x47 &amp;&amp;
    uint8Array\[4\] === 0x0d &amp;&amp;
    uint8Array\[5\] === 0x0a &amp;&amp;
    uint8Array\[6\] === 0x1a &amp;&amp;
    uint8Array\[7\] === 0x0a
) &#123;
    return &#39;png&#39;;
&#125;

// Check for JPEG (first 3 bytes: FF D8 FF)
if (uint8Array\[0\] === 0xff &amp;&amp; uint8Array\[1\] === 0xd8 &amp;&amp; uint8Array\[2\] === 0xff) &#123;
    return &#39;jpeg&#39;;
&#125;

// Check for GIF (first 6 bytes: GIF87a or GIF89a)
if (
    uint8Array\[0\] === 0x47 &amp;&amp;
    uint8Array\[1\] === 0x49 &amp;&amp;
    uint8Array\[2\] === 0x46 &amp;&amp;
    uint8Array\[3\] === 0x38 &amp;&amp;
    (uint8Array\[4\] === 0x37 || uint8Array\[4\] === 0x39) &amp;&amp;
    uint8Array\[5\] === 0x61
) &#123;
    return &#39;gif&#39;;
&#125;

// Check for BMP (first 2 bytes: 42 4D)
if (uint8Array\[0\] === 0x42 &amp;&amp; uint8Array\[1\] === 0x4d) &#123;
    return &#39;bmp&#39;;
&#125;

// Check for WebP (first 4 bytes: 52 49 46 46 and &quot;WEBP&quot; in bytes 8-11)
if (
    uint8Array\[0\] === 0x52 &amp;&amp;
    uint8Array\[1\] === 0x49 &amp;&amp;
    uint8Array\[2\] === 0x46 &amp;&amp;
    uint8Array\[3\] === 0x46 &amp;&amp;
    uint8Array\[8\] === 0x57 &amp;&amp;
    uint8Array\[9\] === 0x45 &amp;&amp;
    uint8Array\[10\] === 0x42 &amp;&amp;
    uint8Array\[11\] === 0x50
) &#123;
    return &#39;webp&#39;;
&#125;

return &#39;Unknown format&#39;;
</code></pre>
<p>}</p>
<p>部署</p>
<p>npm install @cf-wasm&#x2F;photon<br>npm install blurhash<br>wrangler deploy </p>
<p>就可以了。wrangler会自动打包，把依赖和wasm也一起上传上去</p>
<h2 id="Azure-Function"><a href="#Azure-Function" class="headerlink" title="Azure Function"></a>Azure Function</h2><p>如果你使用的是Azure Function，那么事情就简单多了，直接安装并使用 sharp 就行。需要注意的一点是，Azure Function可以选择运行的环境是Linux还是Windows。所以本地也要安装好正确的sharp然后才可以部署。</p>
<p>npm install –cpu&#x3D;x64 –os&#x3D;linux sharp</p>
<p>详情可以参考<a target="_blank" rel="noopener" href="https://sharp.pixelplumbing.com/install#cross-platform">Cross-platform</a></p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>原来是打算把 Worker和Function 用同一套代码库的，但是由于 Worker的限制，即使不同情况下使用不同的import，Worker还是没法兼容 Function🫠</p>
<p>所以只能分开两个分支了。</p>
<p><img src="/images/2024092817391160.png" alt="表格 描述已自动生成"></p>
<p>Cloudflare Workers 太弱智了，害我失去了人生中宝贵的三个小时<a target="_blank" rel="noopener" href="https://dmesg.app/wp-content/uploads/2024/09/2024092817391148.png"><img src="/images/2024092817391148.png" alt="卡通人物 中度可信度描述已自动生成"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/28/worker-image-metadata/index/" data-id="cm1mqfxms0000d8jf1uap05xh" data-title="使用 Cloudflare Worker获取图片元数据" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-workers-function/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/27/workers-function/index/" class="article-date">
  <time class="dt-published" datetime="2024-09-27T00:00:00.000Z" itemprop="datePublished">2024-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/azure/">azure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/27/workers-function/index/">将 Cloudflare Workers 迁移到 Azure Function</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>WebP Cloud Services<a target="_blank" rel="noopener" href="https://blog.webp.se/cloudflare-workers-origin-zh/">使用 Cloudflare Workers进行回源来保证原站服务器IP不泄漏</a>。本着降本增效的理念，我们这次准备将部分回源请求迁移到 Azure Function。</p>
<p>Azure Function 同样也是由 Azure 提供的serverless服务，运行时可以使用 Python、NodeJS、Java和亲儿子 .NET、PowerShell，和 Cloudflare Workers一样，每个月前100万请求免费，具体信息可以参考价格表</p>
<p>我们的回源代码是使用 JavaScript写的，虽然这个语言挺扭曲的，但是为了方便迁移，就不变啦！</p>
<h1 id="创建-Azure-账号"><a href="#创建-Azure-账号" class="headerlink" title="创建 Azure 账号"></a>创建 Azure 账号</h1><p>你需要有一个活跃订阅的Azure账号……</p>
<h1 id="创建-Function"><a href="#创建-Function" class="headerlink" title="创建 Function"></a>创建 Function</h1><p>搜索栏搜索 Function App，点击 Create 按钮，会发现 Azure 提供了五种选项。选择第一个 Consumption</p>
<p><img src="/images/2024092621330760.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>进入配置页面，可以新建一个资源组，需要选择的是 Runtime，这里选择 nodejs，然后 Region选择离用户最接近的地方。这里和 Cloudflare Workers不一样，Cloudflare Workers是在全球部署的，会在离用户最近的节点执行；Azure 这里是在固定的节点执行，所以对于大陆用户来说，日韩港新是比较不错的位置。</p>
<p><img src="/images/2024092621330965.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>默认就行，要是看默认的名字不喜欢，可以自己改掉</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>这里要选择Enable public access，要不然访问不了。</p>
<p><img src="/images/2024092621331055.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><p>Monitoring 想开就开，为了省钱可以关掉。当然后续也可以重新开启；</p>
<p>Deployment是配置CD的地方，可以以后再配置</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>部署完成之后 Azure 会提供一个URL，打开之后应该是这样的</p>
<p><img src="/images/2024092621331135.png" alt="图形用户界面, 应用程序, 网站 描述已自动生成"></p>
<h2 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h2><p>不像 Cloudflare Workers 那么直接，开发 Azure Functions 最好用 VS Code。因为用 Azure Functions 扩展会很方便。</p>
<p>然后按F1弹出窗口 Azure Functions – Create New Project，语言就选择 JavaScript，愿意做类型体操也可以选择 TypeScript，或者任何你熟悉的语言都可以。</p>
<p><img src="/images/2024092621331236.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>Trigger为如何触发Functions，这个场景下选择HTTP Trigger就可以了</p>
<p><img src="/images/202409262133137.png" alt="图形用户界面 描述已自动生成"></p>
<h2 id="熟悉开发环境"><a href="#熟悉开发环境" class="headerlink" title="熟悉开发环境"></a>熟悉开发环境</h2><h3 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h3><ul>
<li><code>src/functions/fetchImage.js</code> 这个就是你的代码</li>
<li><code>host.json</code>：配置</li>
</ul>
<h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>F1 – Deploy to Function App，选择订阅-刚刚创建的function</p>
<p>部署成功之后，浏览器访问：</p>
<p><a target="_blank" rel="noopener" href="https://blog-fun-post.azurewebsites.net/api/fetchimage">https://blog-fun-post.azurewebsites.net/api/fetchimage</a></p>
<p>就可以看到 Hello World信息了。其中：</p>
<ul>
<li><code>api</code>是路由前缀，可以自定义的</li>
<li><code>fetchimage</code>是代码里写好的路由，当然也可以自定义，默认代码里定义的name</li>
</ul>
<p>Azure 上可以看到已经部署好的代码</p>
<p><img src="/images/2024092621331341.png" alt="图片包含 图形用户界面 描述已自动生成"></p>
<p>点进去终于有了和 Cloudflare Workers一样的在线编辑页面（不过可能是只读的，和选择的语言有关）</p>
<p><img src="/images/2024092621331482.png" alt="图形用户界面, 文本, 应用程序, 电子邮件 描述已自动生成"></p>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>每次改代码都部署一次确实不是好办法。这个时候就要用本地调试啦，由于我们是用 HTTP trigger的，调试起来非常简单方便。哦对了，调试 JavaScript 应用得有nodejs</p>
<p>打开 <code>fetchImage.js</code> 按下F5，这里选择 Connect Storage Account（其实选择 emulator绕过去也行，没关系）</p>
<p><img src="/images/2024092621331673.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>如果是第一次运行，可能需要安装一些依赖，安装完成之后就会看到控制台输出了类似如下信息</p>
<p>Azure Functions Core Tools<br>Core Tools Version: 4.0.6280 Commit hash: N&#x2F;A +421f0144b42047aa289ce691dc6db4fc8b6143e6 (64-bit)<br>Function Runtime Version: 4.834.3.22875<br>[2024-09-26T12:27:04.937Z] Debugger listening on ws:&#x2F;&#x2F;127.0.0.1:9229&#x2F;882fb0c8-1957-4070-a6be-9cfd3250d77b<br>[2024-09-26T12:27:04.938Z] For help, see: <a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/inspector">https://nodejs.org/en/docs/inspector</a><br>[2024-09-26T12:27:05.003Z] Worker process started and initialized.<br>[2024-09-26T12:27:05.058Z] Debugger attached.<br>Functions:<br>fetchImage: [GET,POST] <a target="_blank" rel="noopener" href="http://localhost:7071/api/fetchImage">http://localhost:7071/api/fetchImage</a><br>For detailed output, run func with –verbose flag.</p>
<p>浏览器访问<code>http://localhost:7071/api/fetchImag</code>e 就可以了，改了代码也会自动热加载，当然也可以打断点。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>一个最简单的 Functions 代码是这样的</p>
<p>const { app } &#x3D; require(‘@azure&#x2F;functions’);</p>
<p>app.http(‘fetch’, {<br>    methods: [‘GET’, ‘POST’],<br>    authLevel: ‘anonymous’,<br>    handler: async (request, context) &#x3D;&gt; {<br>        context.log(`Http function processed request for url “${request.url}”`);<br>        return { body: `Hello hello hello` };<br>    },<br>});</p>
<ul>
<li><code>app.http</code> 的第一个参数是名字，要唯一，并且默认是路由</li>
<li><code>methods</code>表示接受的请求方法</li>
<li><code>handler</code>是处理请求的地方，第一个参数是<code>request</code>，可以用来获取请求体之类的信息，第二个是<code>context</code>，执行上下文，包括日志功能、绑定数据、环境信息等。</li>
<li><code>return</code> 用于返回响应，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-node?tabs=javascript,windows,azure-cli&pivots=nodejs-model-v4">按照文档</a> <code>context.res</code> 也应该可以，但是在我这里不行，可能<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42548199/azure-function-not-returning-response-through-context-res">需要额外配置一下</a>。返回一个object，编辑器会自动补全，比如body, status,headers 等</li>
</ul>
<h2 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h2><h3 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h3><p>默认，functions的代码都是 在 <code>/api</code> 这个路由下的，在 <code>host.json</code> 里可以进行配置</p>
<p>“extensions”: {<br>    “http”: {<br>      “routePrefix”: “”<br>    }<br>  }</p>
<p>这样就没有 <code>api</code> 这个前缀了，当然你也可以随便改！</p>
<h3 id="路由名称"><a href="#路由名称" class="headerlink" title="路由名称"></a>路由名称</h3><p>默认路由名称是<code>app.http</code> 的第一个参数，如</p>
<p>app.http(‘fetch’, {<br>    methods: [‘GET’, ‘POST’],<br>    authLevel: ‘anonymous’,<br>    handler: handler,<br>});</p>
<p>那么路由就是 <code>fetch</code> ，如果要自定义可以额外传入一个 <code>route</code>。需要注意不可以是空字符串，也不可以是<code>/</code>开头的</p>
<p>app.http(‘fetch’, {<br>    methods: [‘GET’, ‘POST’],<br>    authLevel: ‘anonymous’,<br>    handler: handler,<br>    route: “something”<br>});</p>
<h2 id="根访问"><a href="#根访问" class="headerlink" title="根访问"></a>根访问</h2><p>如果你希望应用在 <a href="https://example.com/">https://example.com</a> 直接访问，不需要<code>/api</code> 也不需要路由名称，那么就要综合以上两种方法，配置前缀，然后 <code>route: &quot;/&quot;</code>不能留空😂，如果留空就会出现azure默认的页面 [v_tips]又一个人生小技巧🫠[&#x2F;v_tips]</p>
<h2 id="迁移代码"><a href="#迁移代码" class="headerlink" title="迁移代码"></a>迁移代码</h2><p>我们的Cloudflare Workers代码是这么写的，非常简单</p>
<p>async function handleProxy(post_body) {<br>    const headers &#x3D; {<br>        “Accept”: post_body.accept,<br>        “User-Agent”: post_body.user_agent<br>    };</p>
<pre><code>const response = await fetch(post\_body.origin\_url, &#123;
    method: post\_body.request\_name,
    headers: headers
&#125;);

if (response.ok) &#123;
    const res = new Response(response.body, &#123;
        status: response.status,
        statusText: response.statusText,
        headers: response.headers
    &#125;);
    return res;
&#125; else &#123;
    return new Response(response.statusText || &quot;Unknown Error&quot;, &#123;
        status: response.status,
        statusText: response.statusText
    &#125;);
&#125;
</code></pre>
<p>}</p>
<p>export default {<br>    async fetch(request, env, ctx) {<br>        try {<br>            const post_body &#x3D; await request.json();<br>            return handleProxy(post_body);<br>        } catch (error) {<br>            return new Response(“Invalid JSON data”, { status: 400 });<br>        }<br>    },<br>};</p>
<p>基本上要改的地方如下：</p>
<ol>
<li>入口参数位置调换</li>
<li>改改函数名字之类的</li>
</ol>
<p>也就是改一下那个<code>default</code></p>
<p>async function handler(request, context) {<br>    try {<br>        const body &#x3D; await request.json();<br>        return handleProxy(body);<br>    } catch (error) {<br>        console.error(‘JSON parsing error:’, error);<br>        return new Response(‘Invalid JSON data’, { status: 400 });<br>    }<br>}</p>
<p>好了你的函数写好了，可以部署了。就是这么简单，除了配置环境那里麻烦点，别的都很容易，毕竟大家都是nodejs 20,自带了<code>fetch</code>和<code>Response</code></p>
<p>甚至可以通过运行时信息不同，使用不同的入口函数，进而做到用一套代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Function提供的语言比Cloudflare Workers多</li>
<li>大家都是JavaScript，迁移很简单。为了类型安全也可以使用 TypeScript</li>
<li>Function是区域性部署；Workers是全球部署且就近执行</li>
<li>Function 想要做到就近执行，可能得需要配合 FrontDoor + 多地部署，想想就头疼</li>
<li>Function提供的计划挺多的</li>
<li>Function也应该可以拿来做一些奇奇怪怪的事情</li>
<li>Azure的线路很好，对大陆访问非常友好，而Cloudflare则是降速CDN了</li>
<li>Azure的功能好多（价格也很美丽），还待以后慢慢学习尝试</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/27/workers-function/index/" data-id="cm1lb077g0000s4jfgb3g1yfv" data-title="将 Cloudflare Workers 迁移到 Azure Function" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-one-api-clickhouse/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/21/one-api-clickhouse/index/" class="article-date">
  <time class="dt-published" datetime="2024-09-21T00:00:00.000Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">program</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/21/one-api-clickhouse/index/">one-api/new-api性能优化：使用 ClickHouse 作为日志系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>one-api&#x2F;new-api是一款开源的OpenAI 接口管理 &amp; 分发系统，支持OpenAI、Anthropic、Gemini等多种模型。</p>
<p>这套系统，从使用者的角度来看，用起来倒还好，UI很简洁；从开发者的角度来看，作者挺不容易的要用Go来处理各种奇奇怪怪的序列化问题，一旦请求数量过多并发就无法提升，除此之外也有很多<a target="_blank" rel="noopener" href="https://t.me/mikuri520/2836">奇奇怪怪的地方啦</a>……</p>
<hr>
<p>我的<a target="_blank" rel="noopener" href="https://burn.hair/">OpenAI接口转发站 「头顶冒火」</a> 就是在这个基础之上搭建的。只不过经过了我的大量修改，比如加个数据看板这种前端的功能</p>
<p><a target="_blank" rel="noopener" href="https://dmesg.app/wp-content/uploads/2024/09/2024092119325495.jpg"><img src="/images/2024092119325495.jpg"></a></p>
<p>以及默默的看不见的后台优化。经过我的一番调教之后，目前在Hetzner 2C 2G的机器上已经能达到几百的QPS了。当然实际使用，还得看真正的API能够提供多少TPM和RPM。</p>
<hr>
<p>在高并发的情况下，本来数据库的压力就比较大，如果还开启了日志记录功能，那么数据库就会被大量的日志写入直接撑爆；另外，即使在非高负载的情况下，在日志条目比较多的时候，查看每一页日志的请求速度也会很慢。</p>
<p>优化并发最简单、并且大概率好用的办法之一是用更高配置的机器。但是一般来说，<strong>提升到一定配置之后，再提升基本没帮助，也就是陷入边际效应递减</strong>。而且对于我这种穷人，自然只能靠变异优化了。</p>
<p>本文将介绍如何使用 ClickHouse替换原有的日志系统，避免在高并发的时候清空恶化并降低性能。至于其他方面的优化，等以后再说～</p>
<h2 id="one-api的数据库"><a href="#one-api的数据库" class="headerlink" title="one-api的数据库"></a>one-api的数据库</h2><p>one-api默认支持三种数据库，SQLite，MySQL和PostgreSQL。</p>
<ul>
<li>SQLite：嵌入式的数据库，只有一个文件。在高并发下，即使允许多线程读写，其性能也不会好到哪里去。</li>
<li>MySQL：知名的RDBMS</li>
<li>PostgreSQL：PostgreSQL应该有更丰富的功能和特性。</li>
</ul>
<p>如果你实在懒得自己优化，直接换成 PostgreSQL+高配置的机器吧，PostgreSQL的性能应该会好过MySQL一些。</p>
<h2 id="one-api的日志系统：写入"><a href="#one-api的日志系统：写入" class="headerlink" title="one-api的日志系统：写入"></a>one-api的日志系统：写入</h2><p>One-api的普通数据和日志默认情况下均记录在同一个数据库之中，其Go Struct Model 如下</p>
<p>type Log struct {<br>    Id               int    `json:”id”`<br>    UserId           int    `json:”user_id” gorm:”index”`<br>    CreatedAt        int64  `json:”created_at” gorm:”bigint;index:idx_created_at_type”`<br>    Type             int    `json:”type” gorm:”index:idx_created_at_type”`<br>    Content          string `json:”content”`<br>    Username         string `json:”username” gorm:”index:index_username_model_name,priority:2;default:’’”`<br>    TokenName        string `json:”token_name” gorm:”index;default:’’”`<br>    ModelName        string `json:”model_name” gorm:”index;index:index_username_model_name,priority:1;default:’’”`<br>    Quota            int    `json:”quota” gorm:”default:0”`<br>    PromptTokens     int    `json:”prompt_tokens” gorm:”default:0”`<br>    CompletionTokens int    `json:”completion_tokens” gorm:”default:0”`<br>    ChannelId        int    `json:”channel” gorm:”index”`<br>}</p>
<p>默认配置下，每一次请求，都会调用 <code>RecordConsumeLog</code> 写入日志，其代码非常简单</p>
<p>log :&#x3D; &amp;Log{<br>    UserId:           userId,<br>    Username:         GetUsernameById(userId),<br>    CreatedAt:        helper.GetTimestamp(),<br>    Type:             LogTypeConsume,<br>    Content:          content,<br>    PromptTokens:     promptTokens,<br>    CompletionTokens: completionTokens,<br>    TokenName:        tokenName,<br>    ModelName:        modelName,<br>    Quota:            int(quota),<br>    ChannelId:        channelId,<br>}<br>err :&#x3D; LOG_DB.Create(log).Error</p>
<h3 id="逐条写入日志"><a href="#逐条写入日志" class="headerlink" title="逐条写入日志"></a>逐条写入日志</h3><p>在请求数量比较多的情况下，这相当于是一条一条的执行 insert 语句。这种情况下主要有以下缺点：</p>
<ol>
<li>网络延迟：每次操作都有往返的RTT、通信开销</li>
<li>事务开销：每次操作都要开启和关闭事务</li>
<li>负载：频繁插入会导致CPU和IO负载增加</li>
</ol>
<p>即使你很有钱，用到了每个月几百几千美元配置和价格奇高的Managed database，1和2的问题还是无法避免</p>
<h3 id="insert-many优化"><a href="#insert-many优化" class="headerlink" title="insert_many优化"></a>insert_many优化</h3><p>使用 insert_many，积攒一定的数据之后一起插入，这是一种非常简单的优化思路。这种办法也有些缺点：</p>
<ol>
<li>要等数据积攒到一定程度，会有一定的延迟</li>
<li>积攒数据到时候可能会有内存消耗过多的风险</li>
<li>可能会有更高的失败概率，一次性插入数据过多，可能会有 <code>max_allowed_packet</code> 之类的问题</li>
</ol>
<p>优点很明显，一次性写入数据可比一条一条写要快上很多倍了。</p>
<p>one-api自带了一个类似的功能，环境变量<code>BATCH_UPDATE_ENABLED</code> 和 <code>BATCH_UPDATE_INTERVAL</code> 。不过截止到我写本文的时候，写日志的这部分功能不包含在<code>batchUpdate</code>内…而是在一个go routine内执行的…</p>
<p>更要命的是，这个<code>batchUpdate</code>从设计上来看，只能聚合数值类型的数据😂</p>
<p>func addNewRecord(type_ int, id int, value int64) {<br>    batchUpdateLocks[type_].Lock()<br>    defer batchUpdateLocks[type_].Unlock()<br>    if _, ok :&#x3D; batchUpdateStores[type_][id]; !ok {<br>        batchUpdateStores[type_][id] &#x3D; value<br>    } else {<br>        batchUpdateStores[type_][id] +&#x3D; value<br>    }<br>}</p>
<p>改造一下当然可行，攒够1000条或到一定时间间隔一起写入数据库，难度不高，ChatGPT可以帮忙。</p>
<h2 id="one-api的日志系统：读取"><a href="#one-api的日志系统：读取" class="headerlink" title="one-api的日志系统：读取"></a>one-api的日志系统：读取</h2><p>假如日志很少，那么读取日志并不会造成什么大问题。</p>
<p>但是如果数据量很大，并且还用户点击了下一页，甚至是最后一页进行了分页操作，那么 <code>OFFSET</code>和<code>LIMIT</code> 会显著影响数据库的性能。</p>
<p>MySQL 在执行 <code>OFFSET</code> 时，必须从头开始扫描并丢弃前 <code>OFFSET</code> 条记录，然后返回 <code>LIMIT</code> 条记录，导致较大的时间开销，尤其是 <code>OFFSET</code> 数值较大时。</p>
<p>优化方法应该是有一些的，比如通过主键而不是<code>OFFSET</code> ，具体可以问问ChatGPT，我不是很愿意进行这个方向的研究😂</p>
<h2 id="ClickHouse介绍"><a href="#ClickHouse介绍" class="headerlink" title="ClickHouse介绍"></a>ClickHouse介绍</h2><p>ClickHouse是yandex开发的一个开源列式数据库管理系统，专门为高性能的分析查询而设计，在处理大量数据时有出色的表现。</p>
<p>ClickHouse采用列式存储，不像MySQL等是行式存储，特别适合存储日志。在 WebP Cloud Services 中我们的统计信息来源便是 ClickHouse</p>
<p><a target="_blank" rel="noopener" href="https://dmesg.app/wp-content/uploads/2024/09/202409212031366.png"><img src="/images/202409212031366.png"></a></p>
<p>更重要的是，ClickHouse的查询语句和MySQL、PostgreSQL等几乎没什么差别，基本上改改就能用，学习曲线很平缓。</p>
<h2 id="ClickHouse创建数据库表"><a href="#ClickHouse创建数据库表" class="headerlink" title="ClickHouse创建数据库表"></a>ClickHouse创建数据库表</h2><p>根据上面的Go Struct和已有的数据结构，改改基本上就可以了。为了保持一致，<code>created_at</code> 就用数字时间戳了，虽然使用 <code>datetime</code>是更好的办法。</p>
<p>CREATE TABLE logs<br>(<br>    user_id           Nullable(Int64),<br>    created_at        Int64  DEFAULT toUnixTimestamp(now()),<br>    type              Nullable(Int64),<br>    content           Nullable(String),<br>    username          String DEFAULT ‘’,<br>    token_name        String DEFAULT ‘’,<br>    model_name        String DEFAULT ‘’,<br>    quota             Int64  DEFAULT 0,<br>    prompt_tokens     Int64  DEFAULT 0,<br>    completion_tokens Int64  DEFAULT 0,<br>    ip                Nullable(String),<br>    user_agent        Nullable(String)<br>) ENGINE &#x3D; MergeTree()<br>      ORDER BY (created_at, username, token_name, model_name);</p>
<h2 id="连接到ClickHouse"><a href="#连接到ClickHouse" class="headerlink" title="连接到ClickHouse"></a>连接到ClickHouse</h2><p>使用官方的 github.com&#x2F;ClickHouse&#x2F;clickhouse-go</p>
<p>var ch, err &#x3D; clickhouse.Open(&amp;clickhouse.Options{<br>    Addr: []string{“clickhouse:9000”},<br>    Auth: clickhouse.Auth{<br>        Database: “openai”,<br>        Username: “default”,<br>        Password: “”,<br>    },<br>})</p>
<h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><p>query :&#x3D; `INSERT INTO logs ( user_id, created_at, type, content, username, token_name, model_name,quota, prompt_tokens, completion_tokens, ip, user_agent)`<br>ch.Exec(ctx, query, 1, timestamp, …)</p>
<h2 id="批量写入数据"><a href="#批量写入数据" class="headerlink" title="批量写入数据"></a>批量写入数据</h2><p>Clickhouse最厉害的地方之一是可以批量写入数据，官网上<a target="_blank" rel="noopener" href="https://clickhouse.com/docs/en/cloud/bestpractices/bulk-inserts">是这么说的</a>：</p>
<blockquote>
<p>Generally, we recommend inserting data in fairly large batches of at least 1,000 rows at a time, and ideally between 10,000 to 100,000 rows.</p>
</blockquote>
<p>你看他们多自信，让你攒够了再写，一次写几万没问题</p>
<h3 id="创建batch"><a href="#创建batch" class="headerlink" title="创建batch"></a>创建batch</h3><p>在Go里批量写入，要先创建batch</p>
<p>var batch, err &#x3D; ch.PrepareBatch(ctx, `INSERT INTO logs ( user_id, created_at, type, content, username, token_name, model_name,<br>    quota, prompt_tokens, completion_tokens, ip, user_agent)<br>VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`)</p>
<h3 id="追加数据"><a href="#追加数据" class="headerlink" title="追加数据"></a>追加数据</h3><p>然后往这个 batch里疯狂<code>append</code>数据，也就是在原来的<code>RecordConsumeLog</code> 中追加数据到这个batch</p>
<p>batch.Append(userId, helper.GetTimestamp(),<br>    LogTypeConsume, content, username, tokenName, modelName, quota, promptTokens, completionTokens, ip, ua,<br>)</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>时间差不多了，或者数据足够了，提交</p>
<p>batch.Send()</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>定时器可以用<code>ticker</code></p>
<p>func ClickHouseTicker() {<br>    var ticker &#x3D; time.NewTicker(time.Second * 60)<br>    for {<br>        select {<br>        case &lt;-ticker.C:<br>            FlushLog()<br>        }<br>    }<br>}</p>
<p>在 main里 <code>go ClickHouseTicker()</code>即可</p>
<h3 id="清空batch"><a href="#清空batch" class="headerlink" title="清空batch"></a>清空batch</h3><p>写完数据之后，然后清空batch，不能越写越多</p>
<p>batch&#x3D;createBatch()</p>
<h3 id="程序退出清理工作"><a href="#程序退出清理工作" class="headerlink" title="程序退出清理工作"></a>程序退出清理工作</h3><p>最后，要捕获 SIGINT和SIGTERM信号，不能重启程序的丢日志啊，这个时候就要用到IIFE+goroutine了</p>
<p>sigChan :&#x3D; make(chan os.Signal, 1)<br>signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)<br>go func() {<br>    for {<br>        sig :&#x3D; &lt;-sigChan<br>        switch sig {<br>        case syscall.SIGINT, syscall.SIGTERM:<br>            logger.SysLog(“Cleaning up…”)<br>            model.FlushLog()<br>            model.ConsolidateConsumeQuota()<br>            time.Sleep(time.Second * 2)<br>            syscall.Exit(0)<br>        }<br>    }<br>}()</p>
<h2 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h2><p>查询语法基本和MySQL一样，<code>ch.Query(ctx, query, params…)</code>就行，order by，offset，limit，count等都有</p>
<h2 id="删除日志"><a href="#删除日志" class="headerlink" title="删除日志"></a>删除日志</h2><p>日志总得删掉，要不然磁盘早晚会被撑爆。用类似如下语句就行，最后的 <code>max_execution_time</code> 可选，避免日志真的太多删除也很费时间</p>
<p>DELETE FROM logs WHERE type &#x3D; 2 AND created_at &lt; timestamp SETTINGS max_execution_time&#x3D;3600</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>通过 Grafana + Clickhouse作为数据源，可以直接画图表。之前 QPS 的数据是写入到 influxdb的，一旦超过7天查询就很慢，现在我单独把本应写到 influxdb的数据写到了一个名为 stats 的ClickHouse表，只保存关键的信息，如请求时间，模型名称等。</p>
<p>比如看看大家用得最多的模型，最多的竟然是mini，然后是4o；但是消费是反过来的，因为4o的价格比较贵，mini比较便宜</p>
<p><img src="/images/2024092119153889.png" alt="图形用户界面, 饼图 中度可信度描述已自动生成"></p>
<h2 id="查询性能能提升"><a href="#查询性能能提升" class="headerlink" title="查询性能能提升"></a>查询性能能提升</h2><p>简单的执行三个查询，一共有354万的数据。主要测一下大量翻页，可以看出即使最差的<code>select *</code> 的情况下，ClickHouse大概也有4-5倍的性能提升。</p>
<table><tbody><tr><td>查询</td><td>MySQL</td><td>ClickHouse</td><td>比率</td></tr><tr><td>select count(*) from openai.logs;</td><td>2.73</td><td>0.002</td><td>1365.00</td></tr><tr><td>select user_id from openai.logs limit 3 offset 3000000;</td><td>4.19</td><td>0.022</td><td>190.45</td></tr><tr><td>select * from openai.logs limit 3 offset 3000000;</td><td>12.16</td><td>2.778</td><td>4.38</td></tr></tbody></table>

<p>mysql&gt; select count(*) from openai.logs;<br>+———-+<br>| count(*) |<br>+———-+<br>|  3540771 |<br>+———-+<br>1 row in set (2.73 sec)</p>
<p>mysql&gt; select user_id from openai.logs limit 3 offset 3000000;<br>….<br>3 rows in set (4.19 sec)</p>
<p>mysql&gt; select * from openai.logs limit 3 offset 3000000;<br>….                                                                                                                                                                                                                                                   |<br>3 rows in set (12.16 sec)</p>
<p>c387e15ec5c6 :) select count(*) from openai.logs;</p>
<p>SELECT count(*)<br>FROM openai.logs</p>
<p>Query id: 9382c843-927d-471f-8f6c-85a049d58294</p>
<p>   ┌─count()─┐</p>
<ol>
<li>│ 3540771 │ – 3.54 million<br>└─────────┘</li>
</ol>
<p>1 row in set. Elapsed: 0.002 sec.</p>
<p>c387e15ec5c6 :) select user_id from openai.logs limit 3 offset 3000000;</p>
<p>SELECT user_id<br>FROM openai.logs<br>LIMIT 3000000, 3</p>
<p>Query id: 66d0ea52-6b30-4a73-b313-fc45bdcbaaf2<br>….</p>
<p>3 rows in set. Elapsed: 0.022 sec. Processed 3.29 million rows, 29.64 MB (146.90 million rows&#x2F;s., 1.32 GB&#x2F;s.)<br>Peak memory usage: 4.26 MiB.</p>
<p>c387e15ec5c6 :) select * from openai.logs limit 3 offset 3000000;</p>
<p>SELECT *<br>FROM openai.logs<br>LIMIT 3000000, 3</p>
<p>Query id: 0faf62f4-5203-434a-8b3d-d1bcf032a8d0<br>….<br>3 rows in set. Elapsed: 2.778 sec. Processed 3.01 million rows, 9.26 GB (1.08 million rows&#x2F;s., 3.33 GB&#x2F;s.)<br>Peak memory usage: 258.79 MiB.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>那当然是要自我宣传一下啦！</p>
<p>🌟🌟🌟欢迎注册并使用 <a target="_blank" rel="noopener" href="https://burn.hair/?lang=zh-CN&utm_source=dmesg">头顶冒火 OpenAI 接口转发站</a>，稳定、快速、高并发，注册即赠送 $0.5 测试额度 🌟🌟🌟</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/21/one-api-clickhouse/index/" data-id="cm1cqczkf0000ymjf4qnmejvy" data-title="one-api/new-api性能优化：使用 ClickHouse 作为日志系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-stripe-fraud/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/03/stripe-fraud/index/" class="article-date">
  <time class="dt-published" datetime="2024-08-03T00:00:00.000Z" itemprop="datePublished">2024-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/it/">it</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/03/stripe-fraud/index/">Stripe 如何安全收款并避免盗刷与测卡</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[v_error]警告⚠️ 在大多数国家和地区，盗刷信用卡都是犯罪行为，数额巨大甚至是重罪。请不要以身试法 [&#x2F;v_error] 使用Stripe进行收款是<a target="_blank" rel="noopener" href="https://dmesg.app/stripe-telegram.html">一件非常简单的事情</a>，用起来非常舒适，不想写代码就无代码，会写代码还想自己设计前后端可以用 Stripe Elements。</p>
<p>当你把事情做好了，把你的在线服务上线了，这个时候就一定要考虑一个问题：盗刷与测卡（卡号测试、银行卡测试）。</p>
<p>盗刷很好理解，用偷来的信用卡资料去你的网站上购物；测卡则是用小额交易或者其他方式来确定盗窃来的信用卡是可用的，然后后续再大额诈骗中使用这些信用卡。</p>
<p>毫无疑问，只要是在线电子商务，就一定无法避免盗刷与测卡的。</p>
<p>一个非常重要的事情是，<strong>商户、卡组织与Stripe都有责任与义务阻止盗刷和测卡。</strong></p>
<p>也许有人不理解，为什么商户也有责任与义务阻止盗刷和测卡？我就是把 Stripe 的一个Payment Link放到了网上，某个不怀好意的人看到了去盗刷，主动给我送钱，我为什么要负责？</p>
<p>切勿贪小便宜！真正的持卡人发现了异常的付款记录，他们会去找发卡行争议，发卡行就会找到 Stripe，商户就需要应对争议，这期间不仅要承担争议费，在争议比例过高时Stripe还会封号、甚至罚款。</p>
<p><img src="/images/2024072819003618.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<p>所以，遇到来源不明的欺诈付款，一定要<strong>全额退款</strong>，可不能贪小便宜。</p>
<p>不过如果对方是用支付宝、微信付款的那就不用管了，因为这俩应该是不支持争议的😂</p>
<hr>
<p>前不久，我“惹毛”了一个黑产论坛。这个黑产论坛的人就开始盗刷+测卡。</p>
<p><img src="/images/2024072819003795.png" alt="图形用户界面, 应用程序, 网站 描述已自动生成"></p>
<p>比如这种，人在新加坡用墨西哥的卡🤨，再考虑到我的用户的大部分都是中国人，所以看起来怎么都很像盗刷。</p>
<p>后来他们盗刷不成还恼羞成怒<a target="_blank" rel="noopener" href="https://dmesg.app/hide-in-cf.html">开始DoS我了</a>，峰值竟然有5500万。</p>
<p>至于我是怎么“惹毛”这群人的，以后也许可以写一篇来说说这件事，我觉得这其中的乐趣会比听相声还搞笑🤣，不笑我倒贴你100块。如果你还是想先了解一下，那么看<a target="_blank" rel="noopener" href="https://x.com/DerekNee/status/1783064415048491428">这个Twitter</a>就够了</p>
<hr>
<p>本文的主题是，已经使用了Stripe，如何防患于未然，避免盗刷与测卡？假如在遭遇盗刷，需要立刻做什么事情？</p>
<h2 id="Radar"><a href="#Radar" class="headerlink" title="Radar"></a>Radar</h2><p>Stripe Radar 是Stripe提供的一个反欺诈工具，基于强大的机器学习实现，并且可以自定义许多规则。比如ChatGPT不允许中国的卡付款，类似这样的规则，就可以Radar的规则实现。</p>
<p>Radar不收月费，而是从每笔交易里抽成，Stripe还是很良心而且很会赚钱的。</p>
<p>在遭遇盗刷的时候，<strong>立刻要做的事情就是开启 Radar</strong>，并且根据自己的情况调整灵敏度。同时，审核所有已经通过的付款，如果怀疑是盗刷的，要<strong>立刻全额退款，全额退款无法争议</strong>。在处理完之后，联系 Stripe客户表明自己的情况，要求他们提供协助和建议。</p>
<p>以新加坡为例，Radar风控团队版每笔交易 0.1新币，机器学习版每笔0.08新币。强烈建议开启团队版。</p>
<p>开启了Radar之后，我们可以在 Risk Control里调整Radar的灵敏度</p>
<p><img src="/images/2024072819003967.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<p>根据自己的情况调整即可，比如我在面临大量盗刷的时候，把灵敏度调到了50，意味着所有风险分数高于50的付款都会被拒绝。</p>
<h2 id="3DS"><a href="#3DS" class="headerlink" title="3DS"></a>3DS</h2><p>在某些地方，你可能会看到 Stripe 2D 的说法。这里的2D指的是在线刷卡的时候只要输入卡号、有效期、CVV并且无需进行身份验证（通常是短信或者App推送）。对应的需要验证的则是3DS</p>
<p>在开启了 Radar之后，就可以强制开启3DS了，这样对于盗刷的情况基本可以拦截一大部分，毕竟他们没有卡主的手机。</p>
<p>Radar – Rules- Authenticate Rules，三个默认的3DS规则全部打开</p>
<p><img src="/images/2024072819004024.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<h2 id="自定义阻止规则"><a href="#自定义阻止规则" class="headerlink" title="自定义阻止规则"></a>自定义阻止规则</h2><p>每个人的业务都不同，比如我的这个业务下，美国人不太可能来用，更别提那些非常小众东南亚、加勒比海和非洲国家了。因此对于我来说，我只要允许中国、最多再包含港澳台的银行卡就可以了。</p>
<p>那么我们就可以添加一个这样的自定义阻止规则，表达式这么写，NOT要写最前面而不是写IN之前</p>
<p>NOT (:card_country: IN (‘CN’,’HK’,’MO’,’TW’))</p>
<p>不想接受预付费卡，那么可以这样写</p>
<p>:card_funding: &#x3D; ‘prepaid’</p>
<p>只想接受中港澳台，允许任何国家的Apple Pay、Google Pay（这俩安全系数很高，不太可能是盗刷），那就这么写</p>
<p>Block if NOT (:card_country: IN (‘CN’,’HK’,’MO’,’TW’)) AND NOT(:digital_wallet: IN (‘android_pay’,’apple_pay’))</p>
<p>3DS通过就接受，无所谓发卡国，可以这么写</p>
<p>NOT :is_3d_secure_authenticated:</p>
<blockquote>
<p>某人在某黑产论坛：真不敢c cn的卡</p>
</blockquote>
<p>在Stripe平台上，我们能做的事情差不多只有这么多了。为了防止测卡，我们还需要在自己的集成方式上下点功夫。</p>
<h2 id="测卡的方式"><a href="#测卡的方式" class="headerlink" title="测卡的方式"></a>测卡的方式</h2><p>测卡一般分两种，一种是授权，类似你在某些网站如Cloudflare绑定你的信用卡，并不会真正的扣款，App上一般能看到记录，但是每月账单上未必会有；另外一种则是付款，一般是小额付款，确认卡片有效准备来波大的。</p>
<p><img src="/images/2024072819004098.jpeg" alt="图形用户界面, 文本, 应用程序 中度可信度描述已自动生成"></p>
<h2 id="检测测卡"><a href="#检测测卡" class="headerlink" title="检测测卡"></a>检测测卡</h2><p>首先当然是要检测到测卡。显著增加的拒绝交易其实就可以用来识别测卡。</p>
<ul>
<li>尝试查看付款详情的时候，能看到Stripe会自动屏蔽测卡，如上面的这张截图</li>
<li>Developers的overview页面图表能发现很多失败</li>
</ul>
<p><img src="/images/2024072819004111.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<ul>
<li>在 Developers – Logs 里查找402，也会发现大量记录</li>
</ul>
<p>在发现被搞了之后，我们要赶紧采取措施。哪怕赶紧找到测卡的人的IP给屏蔽了也是办法。当然坏人没那么笨，简单的防火墙规则未必会管用的。</p>
<h2 id="保护-API-Key"><a href="#保护-API-Key" class="headerlink" title="保护 API Key"></a>保护 API Key</h2><p>Stripe的API Key分为两种，一种是Publishable Key可以公开的；另一种是Secret Key，有这个Key就可以访问Stripe的系统和全球金融网络，所以万万不能泄漏</p>
<p>遇到测卡建议无论是否泄漏 secret key，都去吊销生成一个新的，并且添加IP访问白名单</p>
<p><img src="/images/2024072819004129.png" alt="图形用户界面, 文本, 应用程序, 聊天或短信 描述已自动生成"></p>
<h2 id="优化集成方式"><a href="#优化集成方式" class="headerlink" title="优化集成方式"></a>优化集成方式</h2><p>使用 Stripe有很多集成方式，使用 Stripe Payment Link、Stripe Checkout、Stripe Elements是推荐的方式</p>
<p><img src="/images/202407281900421.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<p>用这种集成方式， Radar能够自动捕获到更多的信息，更容易判断盗刷测卡。</p>
<p>其他的方式可能就需要自己手动提供信息了。</p>
<h2 id="添加captcha"><a href="#添加captcha" class="headerlink" title="添加captcha"></a>添加captcha</h2><p>在请求创建 PaymentIntent之前可以加上一个验证码，比如 Cloudflare的turnstile就是非常好的选择。 这样对于大部分的垃圾请求都可以过滤了。</p>
<p>需要注意，turnstile是需要客户端+服务端实现的。只有客户端是不完整的。</p>
<h2 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h2><p>一般来说，单个IP创建 PaymentIntent 不应该太频繁，可以加上频率限制降低被刷概率。</p>
<h2 id="登录会话"><a href="#登录会话" class="headerlink" title="登录会话"></a>登录会话</h2><p>登录了才能购买，类似这种可以降低被刷成本</p>
<h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>根据自己的业务情况，使用不同的规则来屏蔽测卡。甚至还可以根据IP地理位置和发卡国组合，就看想象力了</p>
<h2 id="战果"><a href="#战果" class="headerlink" title="战果"></a>战果</h2><p>这是屏蔽的付款，看这个时间这么接近，人在美国用着泰国、甚至一些奇怪的小国家的卡，风险系数非常高</p>
<p><img src="/images/2024072819004281.jpeg" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>大概拦截了3000欧，恐怖啊😂 最开始规则配置的不太正确，估计误杀了一部分</p>
<p><img src="/images/2024072819004317.png" alt="图形用户界面, 应用程序, Teams 描述已自动生成"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Stripe的文档还是挺不错的，SDK用起来也非常舒服。无论是stripe.js还是python bindings，写满了 type annotations，想用错都难</li>
<li>Stripe的客服也很专业，响应非常迅速</li>
<li>坏人太多啦</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/03/stripe-fraud/index/" data-id="clzepsaz30000epjfdd66d8v9" data-title="Stripe 如何安全收款并避免盗刷与测卡" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hide-in-cf/index" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/27/hide-in-cf/index/" class="article-date">
  <time class="dt-published" datetime="2024-07-27T00:00:00.000Z" itemprop="datePublished">2024-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cloudflare/">cloudflare</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/27/hide-in-cf/index/">隐藏于 Cloudflare 的全球网络之中</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>做一个网站是很简单的事情。买一个域名，买一个服务器，A记录解析过去就好了。</p>
<p>这样做其实有一个非常大的安全隐患，不怀好意的人可以拿到你的服务器的IP，然后就可以做很多坏事，比如 (D)DoS、暴力破解SSH之类的。</p>
<p>一个很简单的办法，就是用 Cloudflare之类的CDN，这样可以隐藏源站IP。这样他们无法直接攻击你的服务器，只能疯狂打 Cloudflare。</p>
<hr>
<p>就像我前不久一样，遭遇了人生中第一次DoS，峰值大概有5500万请求的样子，基本上都被Cloudflare的规则拦住了。</p>
<p><img src="/images/2024072722290473.jpeg" alt="图形用户界面, 图表 描述已自动生成"></p>
<p>[v_tips]有趣的是，攻击来自于 AS4983 ，归属于 Intel。我猜更有可能和Intel® Developer Cloud有关，而不是Intel的内部网络被黑或者员工做坏事。[&#x2F;v_tips]</p>
<p>然而即使使用了 Cloudflare也并不是100%安全。如果使用方式不正确，也有可能暴露源站IP的。如果被抓到了源站IP，那么坏人就可以疯狂给这个IP发起请求，你的Cloudflare规则配置的再好都没有用。</p>
<hr>
<h1 id="泄漏源站IP的方式"><a href="#泄漏源站IP的方式" class="headerlink" title="泄漏源站IP的方式"></a>泄漏源站IP的方式</h1><h2 id="网络空间测绘"><a href="#网络空间测绘" class="headerlink" title="网络空间测绘"></a>网络空间测绘</h2><p>有一些安全公司，如censys、shodan之类的。他们会扫描整个IPv4的地址，然后尝试连接各种常用端口来确定这个IP上都跑了什么服务。</p>
<p>比如说我随便输入一个域名，即使这个域名在Cloudflare之后，也可能看到相关的结果</p>
<p><img src="/images/2024072722290512.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>点进去，通过证书信息就能确认，这个IP大概率是这个网站的，那还不快打？</p>
<h2 id="钓鱼泄漏"><a href="#钓鱼泄漏" class="headerlink" title="钓鱼泄漏"></a>钓鱼泄漏</h2><p>利用目标网站的功能来执行服务器端请求。例如，如果一个网站允许用户输入一个 URL 来获取该 URL 的内容（如网页抓取或 URL 预览功能），可以提供一个由自己控制的 URL。</p>
<p>比如 WebP Cloud Services吧，这个服务是做网站图片加速的，那么自然要去用户给的地址去获取图片，这样IP也就会被泄露啦。当然了聪明如 <a target="_blank" rel="noopener" href="https://nova.moe/">Nova Kowk</a>怎么会让这种事情发生？</p>
<h2 id="其他泄漏方式"><a href="#其他泄漏方式" class="headerlink" title="其他泄漏方式"></a>其他泄漏方式</h2><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p>有一些程序可以通过常用的词语来暴力猜测子域名，有可能配置的时候不小心忘记点亮小云朵，或者自己持有的其他域名解析不小心忘记打码，那么就暴露了。</p>
<h3 id="历史DNS记录"><a href="#历史DNS记录" class="headerlink" title="历史DNS记录"></a>历史DNS记录</h3><p>有些网站提供历史DNS记录，有概率找到</p>
<h3 id="邮件MX记录"><a href="#邮件MX记录" class="headerlink" title="邮件MX记录"></a>邮件MX记录</h3><p>如果自建邮件服务器，那么是肯定会暴露IP了。</p>
<h3 id="Cloudflare信息泄露或者内部作案"><a href="#Cloudflare信息泄露或者内部作案" class="headerlink" title="Cloudflare信息泄露或者内部作案"></a>Cloudflare信息泄露或者内部作案</h3><p>这个概率应该很低。</p>
<hr>
<h1 id="隐藏IP的方式"><a href="#隐藏IP的方式" class="headerlink" title="隐藏IP的方式"></a>隐藏IP的方式</h1><h2 id="屏蔽censys并不完美"><a href="#屏蔽censys并不完美" class="headerlink" title="屏蔽censys并不完美"></a>屏蔽censys并不完美</h2><p>网上一搜censys 你就会发现有很多种办法，说根据UA屏蔽啦，根据IP屏蔽啦等等。</p>
<p>这种做法治标不治本的。今天屏蔽了censys，明天还有densys，甚至简单写个代码，花最多几百G的流量扫一遍全球的IPv4地址也没什么难度。</p>
<h2 id="只允许-Cloudflare的访问很麻烦"><a href="#只允许-Cloudflare的访问很麻烦" class="headerlink" title="只允许 Cloudflare的访问很麻烦"></a>只允许 Cloudflare的访问很麻烦</h2><p>Cloudflare公开了他们的<a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/ips/">IP地址</a>，因此一种办法是把他们的全部IP地址加入白名单中，然后其他所有的IP地址的请求全部拒绝。</p>
<p>这是一种切实可行的办法，然而有如下缺点：</p>
<ol>
<li>需要跟踪 Cloudflare IP变化</li>
<li>需要配置繁琐的iptables、nginx或者WAF等规则，配置起来会比较麻烦</li>
<li>80和443的规则都要配一遍</li>
<li>费心费时费力</li>
<li>一不小心手抖配置错了可能自己都没法SSH</li>
<li>如果你用docker，还会发现<a target="_blank" rel="noopener" href="https://dmesg.app/ufw-vs-docker.html">docker能给你的iptables开个洞 🤦</a></li>
</ol>
<h2 id="Cloudflare-Argo-Tunnel是未来"><a href="#Cloudflare-Argo-Tunnel是未来" class="headerlink" title="Cloudflare Argo Tunnel是未来"></a>Cloudflare Argo Tunnel是未来</h2><p>Argo Tunnel会在你的服务器和Cloudflare 之间创建一个加密的安全隧道，然后这个隧道可以用来承载很多不同种类型的流量，比如 http，tcp，ssh，smb，rdp，甚至是 unix 套接字都可以</p>
<p>你的机器没有公网IP都没关系的，只要你的服务器能够连接到Cloudflare的网络就可以。用起来很简单，甚至都不用学习奇奇怪怪的命令。</p>
<p>去 Cloudflare Zero Trust – Networks – Tunnel 创建 Tunnel，服务器安装 cloudflared，然后添加 Public hostname就可以了</p>
<p><img src="/images/2024072722290647.png" alt="图形用户界面 描述已自动生成"></p>
<p>你的应用程序甚至只用监听在 localhost而不是0.0.0.0，也就是说你的服务器只开一个SSH就够了</p>
<h2 id="隐藏SSH"><a href="#隐藏SSH" class="headerlink" title="隐藏SSH"></a>隐藏SSH</h2><p>更进一步，我们可以连SSH都隐藏起来。在public hostname那里创建一个域名，如果担心子域名被扫到，那就起个随机的子域名</p>
<p>协议选择 SSH，URL选择 <code>127.0.0.1:22</code></p>
<p>然后在你的电脑上运行 cloudflared建立隧道</p>
<p>cloudflared access ssh –hostname something.dmesg.app –url 127.0.0.1:10022</p>
<h1 id="接到你的服务器"><a href="#接到你的服务器" class="headerlink" title="接到你的服务器"></a>接到你的服务器</h1><p>ssh <a href="mailto:&#x72;&#111;&#x6f;&#116;&#x40;&#x31;&#50;&#55;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;">&#x72;&#111;&#x6f;&#116;&#x40;&#x31;&#50;&#55;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;</a> -p 10022 </p>
<p>之后去厂商的WAF里，比如 Azure是这样的，入网全部拒绝</p>
<p><img src="/images/2024072722290775.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>Vultr是这样的，随便添加一个dummy 入网规则</p>
<p><img src="/images/2024072722290851.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<p>这样你的IP在其他人看来完全是黑洞，ping不通，什么端口都没开，就像没被使用一样，只有 Cloudflare知道背后的真相。</p>
<h2 id="隐藏应用程序向外发起的请求"><a href="#隐藏应用程序向外发起的请求" class="headerlink" title="隐藏应用程序向外发起的请求"></a>隐藏应用程序向外发起的请求</h2><p>如果你的应用程序会向外发请求，而这个外部是可以被用户自定义的，那么就存在被钓鱼的情况。即使你配置的再好，那么也会被抓到IP。</p>
<p>这种情况下，要做的事情自然是全方面审查代码，如果遇到会被钓鱼的地方，那么需要让流量走代理。</p>
<p>至于走什么代理，一种方式是走商业VPN，比如Surfshark之类的，通过wireguard转socks5；另一种方式是走 Cloudflare WARP，WARP可以运行在 proxy mode而不是接管全局流量</p>
<p>warp-cli register</p>
<h1 id="warp-监听本地的11111端口"><a href="#warp-监听本地的11111端口" class="headerlink" title="warp 监听本地的11111端口"></a>warp 监听本地的11111端口</h1><p>warp-cli set-proxy-port 11111</p>
<h1 id="warp-proxy-mode"><a href="#warp-proxy-mode" class="headerlink" title="warp proxy mode"></a>warp proxy mode</h1><p>warp-cli set-mode proxy</p>
<h1 id="永久开启"><a href="#永久开启" class="headerlink" title="永久开启"></a>永久开启</h1><p>warp-cli enable-always-on</p>
<p>对于Go的应用，这样就可以了</p>
<p>https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:11111 http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:11111 go run main.go</p>
<p>还有一种方式是使用 Cloudflare Workers，请求由Workers转发，代码很简单</p>
<p>export default {<br>  async fetch(request: Request): Promise {<br>    &#x2F;**<br>     * Replace `remote` with the host you wish to send requests to<br>     *&#x2F;<br>    const remote &#x3D; “<a href="https://example.com/">https://example.com</a>“;</p>
<pre><code>return await fetch(remote, request);
</code></pre>
<p>  },<br>};</p>
<p>更具体的使用方式可以看下面的参考阅读</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哎这个世界上坏人真的太多了，但是 Cloudflare 真的帮助了我很多，更重要的是这一切还都是免费的！</p>
<blockquote>
<p>不得不感慨，「At Cloudflare, we have our eyes set on an ambitious goal — to help build a better Internet.」，真的不仅仅是一句口号。</p>
<p>—— Nova Kowk</p>
</blockquote>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nova.moe/cloudflared-distributed/">分布式部署 cloudflared 让访客就近回源，进一步提升访问速度</a></li>
<li><a target="_blank" rel="noopener" href="https://nova.moe/accelerate-and-secure-with-cloudflared/">使用 Cloudflare Argo Tunnel(cloudflared) 来加速和保护你的网站</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.webp.se/cloudflare-workers-origin-zh/">WebP Cloud 使用 Cloudflare Workers 回源</a></li>
<li><a target="_blank" rel="noopener" href="https://dmesg.app/cloudflare-access-gfwed-server.html">使用 Cloudflare Zero Trust 连接被墙的服务器</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/27/hide-in-cf/index/" data-id="clz73fpm100004zjfdxhg9whw" data-title="隐藏于 Cloudflare 的全球网络之中" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/azure/">azure</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/azure/program/">program</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/china/">china</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/china/justsay/">justsay</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/cloudflare/">cloudflare</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gfw/">gfw</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/it/">it</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/it/justsay/">justsay</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/it/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/it/security/">security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/it/share/">share</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/justsay/">justsay</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/justsay/gfw/">gfw</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/justsay/program/">program</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/security/">security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/website/">website</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/program/share/">share</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/">security</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/security/justsay/">justsay</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/security/program/">program</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/share/">share</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/website/">website</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/website/program/">program</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/what/">what</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/what/gfw/">gfw</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/16/py-azure-oai-proxy/index/">使用50行Python代码实现一个Azure OpenAI Proxy</a>
          </li>
        
          <li>
            <a href="/2024/12/12/candlestick-llm/index/">使用Python 通过K线计算技术指标，并用 LLM 预测趋势</a>
          </li>
        
          <li>
            <a href="/2024/11/03/warp-http-proxy/index/">把 Cloudflare WARP 转换为 http 代理</a>
          </li>
        
          <li>
            <a href="/2024/10/12/aca-php/index/">用 Azure Container Apps 运行PHP网站</a>
          </li>
        
          <li>
            <a href="/2024/10/06/aca-vm-scale/index/">Azure Container Apps 连接到虚拟机并配置CPU自动缩放</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Benny小土豆<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>